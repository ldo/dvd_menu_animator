#!/usr/bin/python3
#+
# This script aims to simplify the job of creating menus for DVD-Video
# discs. It takes as input an SVG graphic created by Inkscape representing the
# menu image and button locations, lets the user choose additional colours for
# displaying menu buttons in their highlighted and selected states, and generates
# files suitable for input to the spumux tool in the dvdauthor package.
#
# Copyright 2010-2017 Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#-

import sys
import os
import re
import array
from xml.parsers.expat import \
    ExpatError
from xml.etree import \
    ElementTree as XMLElementTree
import colorsys
import cairo
import gi
gi.require_version("Gdk", "3.0")
gi.require_version("Gtk", "3.0")
gi.require_version("Rsvg", "2.0")
from gi.repository import \
    GLib, \
    GObject, \
    Gdk, \
    GdkPixbuf, \
    Gtk, \
    Rsvg
# Python3 GTK & related docs ref starts at
# <https://live.gnome.org/PyGObject>, mostly at <http://lazka.github.io/pgi-docs/>,
# also see <https://wiki.gnome.org/action/show/Projects/PyGObject>, non-Python-specific
# docs at <https://developer.gnome.org/references> and tutorial at
# <https://python-gtk-3-tutorial.readthedocs.org/en/latest/>

# Porting todo (see notes at <http://wiki.sugarlabs.org/go/Features/GTK3/Porting>):
# * see note about constructors
# * drag-and-drop changes

import getopt

import spuhelper

#+
# Miscellaneous useful stuff
#-

class Point :
    """two-dimensional points."""
    # subset of the code from Linear2D

    def __init__(self, h, v) :
        (self.h, self.v) = (h, v)
    #end __init__

    def __neg__(self) :
        """reflect across origin."""
        return Point \
          (
            h = - self.h,
            v = - self.v
          )
    #end __neg__

#end Point

class Matrix :
    """a 3x3 matrix representing an arbitrary 2D linear transformation."""
    # subset of the code from Linear2D

    def __init__(self, xx, xy, x0, yx, yy, y0, u, v, w) :
        self.xx = xx
        self.xy = xy
        self.x0 = x0
        self.yx = yx
        self.yy = yy
        self.y0 = y0
        self.u = u
        self.v = v
        self.w = w
    #end __init__

    @staticmethod
    def identity() :
        """returns an identity matrix."""
        return Matrix(1, 0, 0, 0, 1, 0, 0, 0, 1)
    #end identity

    def __mul__(m1, m2) :
        """returns concatenation with another matrix."""
        return Matrix \
          (
            xx = m2.xx * m1.xx + m2.xy * m1.yx + m2.x0 * m1.u,
            xy = m2.xx * m1.xy + m2.xy * m1.yy + m2.x0 * m1.v,
            x0 = m2.xx * m1.x0 + m2.xy * m1.y0 + m2.x0 * m1.w,
            yx = m2.yx * m1.xx + m2.yy * m1.yx + m2.y0 * m1.u,
            yy = m2.yx * m1.xy + m2.yy * m1.yy + m2.y0 * m1.v,
            y0 = m2.yx * m1.x0 + m2.yy * m1.y0 + m2.y0 * m1.w,
            u = m2.u * m1.xx + m2.v * m1.yx + m2.w * m1.u,
            v = m2.u * m1.xy + m2.v * m1.yy + m2.w * m1.v,
            w = m2.u * m1.x0 + m2.v * m1.y0 + m2.w * m1.w,
          )
    #end __mul__

    @staticmethod
    def translation(delta) :
        """returns a matrix that translates by the specified delta Point."""
        return Matrix(1, 0, delta.h, 0, 1, delta.v, 0, 0, 1)
    #end translation

    @staticmethod
    def scaling(factor) :
        """returns a matrix that scales by the specified Point factors."""
        return Matrix(factor.h, 0, 0, 0, factor.v, 0, 0, 0, 1)
    #end scaling

    @staticmethod
    def rotation(angle) :
        """returns a matrix that rotates about the origin by the specified
        angle in radians."""
        cos = math.cos(angle)
        sin = math.sin(angle)
        return Matrix(cos, -sin, 0, sin, cos, 0, 0, 0, 1)
    #end rotation

    def __repr__(self) :
        return \
            (
                "Matrix(%f, %f, %f, %f, %f, %f, %f, %f, %f)"
            %
                (
                    self.xx, self.xy, self.x0,
                    self.yx, self.yy, self.y0,
                    self.u, self.v, self.w,
                )
            )
    #end __repr__

#end Matrix

def to_cairo(m) :
    """converts the arg to a Cairo Matrix."""
    return \
        cairo.Matrix \
          (
            xx = m.xx / m.w,
            xy = m.xy / m.w,
            x0 = m.x0 / m.w,
            yx = m.yx / m.w,
            yy = m.yy / m.w,
            y0 = m.y0 / m.w
          )
#end to_cairo

def rect_matrix(srcrect, dstrect) :
    """returns a Cairo matrix that maps the corners of srcrect to dstrect."""
    result = cairo.Matrix()
    result.translate(- srcrect[0], - srcrect[1])
    result.scale(dstrect[2] / srcrect[2], dstrect[3] / srcrect[3])
    result.translate(dstrect[0], dstrect[1])
    return result
#end rect_matrix

def map_button(bounds, srcdimensions, dstdimensions) :
    """returns bounds (l, t, w, h) mapped from srcdimensions (w, h) to
    dstdimensions (w, h)."""
    return \
        (
            bounds[0] * dstdimensions[0] / srcdimensions[0],
            bounds[1] * dstdimensions[1] / srcdimensions[1],
            bounds[2] * dstdimensions[0] / srcdimensions[0],
            bounds[3] * dstdimensions[1] / srcdimensions[1],
        )
#end map_button

def map_button_rect(button_bounds, srcbounds, dstbounds) :
    """returns button_bounds mapped from srcbounds to dstbounds."""
    return \
        (
            (button_bounds[0] - srcbounds[0]) * dstbounds[2] / srcbounds[2] + dstbounds[0],
            (button_bounds[1] - srcbounds[1]) * dstbounds[3] / srcbounds[3] + dstbounds[1],
            button_bounds[2] * dstbounds[2] / srcbounds[2],
            button_bounds[3] * dstbounds[3] / srcbounds[3],
        )
#end map_button_rect

class xdg_base_dir :
    "Implementation of relevant parts of the XDG Base Directory specification" \
    " <http://standards.freedesktop.org/basedir-spec/latest/>."

    @classmethod
    def get_config_home(self) :
        """returns the directory for holding user-specific config files."""
        result = os.environ.get("XDG_CONFIG_HOME")
        if result == None :
            result = os.path.join(os.environ["HOME"], ".config")
        #end if
        return result
    #end get_config_home

    @classmethod
    def config_search_path(self) :
        """returns the list of config directories to search (apart from the user area)."""
        return tuple(os.environ.get("XDG_CONFIG_DIRS", "/etc").split(":"))
          # note spec actually says default should be /etc/xdg, but /etc is the
          # conventional location for system config files.
    #end config_search_path

    @classmethod
    def find_first_config_path(self, path) :
        """searches for path in all the config directory locations in order of decreasing
        priority, returning the expansion where it is first found, or None if not found."""
        paths_to_try = iter((self.get_config_home(),) + self.config_search_path())
            # highest priority first
        while True :
            this_path = next(paths_to_try, None)
            if this_path == None :
                break
            this_path = os.path.join(this_path, path)
            if os.path.exists(this_path) :
                break
        #end while
        return this_path
    #end find_first_config_path

#end xdg_base_dir

valid_video_formats = frozenset(("NTSC", "PAL"))

def get_default_video_format() :
    "implements the video-format preference proposal documented at" \
    " <http://create.freedesktop.org/wiki/Video_Format_Pref>."
    video_format = os.environ.get("VIDEO_FORMAT")
    if video_format == None :
        config_file = xdg_base_dir.find_first_config_path("video_format")
        if config_file != None :
            try :
                video_format = open(config_file, "r").readline().strip()
            except IOError :
                video_format = None
            #end try
        #end if
    #end if
    if video_format != None :
        video_format = video_format.upper()
        if video_format not in valid_video_formats :
            video_format = None
        #end if
    #end if
    return video_format
#end get_default_video_format

color_approx_count_factor = 19
  # ignore excess colours provided they make up no more than a proportion
  # 1 / count_factor of the pixels

class Failure(Exception) :

    def __init__(self, msg) :
        self.msg = msg
    #end __init__

#end Failure

class ns :
    """XML namespaces used in SVG files."""
    svg = "http://www.w3.org/2000/svg"
    sodipodi = "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
    inkscape = "http://www.inkscape.org/namespaces/inkscape"
#end ns

def get_svg_length(tag, attr) :
    """parses the attribute attr of the specified tag as a number optionally
    followed by a units string, and returns a tuple of the two parts."""
    val = re.search("^([0-9\.]+)([a-z\\%]*)$", tag.get(attr)).groups()
    return (float(val[0]), val[1])
#end get_svg_length

class keyval :
    """are there official symbolic names for these anywhere?"""
    returnkey = 0xff0d
    enterkey = 0xff8d
    leftkey = 65361
    upkey = 65362
    rightkey = 65363
    downkey = 65364
#end keyval

select_delay = 0.25
  # how long to display a button in the selected state

#+
# Useful GUI stuff
#-

def box_pack(the_widget, the_box) :
    """packes the_widget at the start of the_box and also returns it."""
    the_box.pack_start(the_widget, False, False, 0)
    return the_widget
#end box_pack

def new_menu(in_menu_bar, label) :
    """creates a new menu in the specified menu bar with the specified name."""
    bar_menu_item = Gtk.MenuItem(label = label)
    the_menu = Gtk.Menu()
    bar_menu_item.set_submenu(the_menu)
    in_menu_bar.append(bar_menu_item)
    return the_menu
#end new_menu

def new_menu_item(in_menu, label, accel_group, accel_key, action) :
    """creates a new item in the specified menu with the specified label,
    action to be performed on selection, and optional accelerator key."""
    the_item = Gtk.MenuItem(label = label)
    the_item.connect("activate", action)
    in_menu.append(the_item)
    if accel_group != None :
        the_item.add_accelerator \
          (
            accel_signal = "activate",
            accel_group = accel_group,
            accel_key = ord(accel_key),
            accel_mods = Gdk.ModifierType.CONTROL_MASK,
            accel_flags = Gtk.AccelFlags.VISIBLE
          )
    #end if
    return the_item
#end new_menu_item

def new_menu_separator_item(in_menu) :
    """creates a new separator item in the specified menu."""
    the_item = Gtk.MenuItem(label = None)
    in_menu.append(the_item)
#end new_menu_separator_item

def define_scrolling_list \
  (
    list_model, # the list/tree model to use
    col, # which column of list_model to get cell value from
    heading, # heading for display
    bounds, # list bounds
    renderer, # defaults to text renderer if omitted
    col_attribute, # name of renderer attribute to set to cell value
    on_selection_changed, # the action to connect to the "changed" signal
    add_to_box, # the HBox or VBox in which to pack the list
  ) :
    """creates a single-column scrolling list of items taken from the specified
    column of list_model, with the specified heading."""
    list_display = Gtk.TreeView(model = list_model)
    column = Gtk.TreeViewColumn(heading)
    column.set_alignment(0)
    list_display.append_column(column)
    if renderer == None :
        renderer = Gtk.CellRendererText()
    #end if
    column.pack_start(renderer, True)
    if col_attribute == None and hasattr(renderer, "do_celldata") :
        column.set_cell_data_func(renderer, renderer.do_celldata, None)
          # do_celldata should be a static method
    else :
        column.add_attribute(renderer, col_attribute, col)
    #end if
    list_scrolled_display = Gtk.ScrolledWindow()
    list_scrolled_display.set_policy \
      (
        hscrollbar_policy = Gtk.PolicyType.NEVER,
        vscrollbar_policy = Gtk.PolicyType.ALWAYS
      )
    list_scrolled_display.add(list_display)
    list_scrolled_display.set_size_request(*bounds)
    box_pack(list_scrolled_display, add_to_box)
    list_selection = list_display.get_selection()
    list_selection.set_mode(Gtk.SelectionMode.SINGLE)
    if on_selection_changed != None :
        list_selection.connect("changed", on_selection_changed)
    #end if
    return list_display
#end define_scrolling_list

def get_single_list_selection(list_display, col) :
    """returns the value from the specified column of the currently-selected item
    in a list, or None if none."""
    selected_items = list_display.get_selection().get_selected_rows()
    if len(selected_items[1]) != 0 :
        selection = tuple(selected_items[0][selected_items[1][0]])[col]
    else :
        selection = None
    #end if
    return selection
#end get_single_list_selection

class ColorCellRenderer(Gtk.CellRenderer) :
    """renders a list cell showing a colour with optional opacity."""

    #def __init__(self) :
    #     mustn't be present (at least as of GTK2), or it doesn't get initialized properly
    #end __init__

    # note use of “do_” method-name prefixes in lieu of CellRendererClass,
    # as per <https://stackoverflow.com/questions/14998298/how-to-write-custom-gtk-cellrenderer-in-python-and-gtk-3>

    def do_get_size(self, draw_owner, cell_rect) :
        return (0, 0, 160, 20)
    #end do_get_size

    @staticmethod
    def do_celldata(column, cell, model, iter, user_data) :
        cell.color = tuple(i / 255 for i in model.get_value(iter, 0))
    #end do_celldata

    def do_render(self, draw, draw_owner, background_rect, cell_rect, flags) :
        draw.set_operator(cairo.OPERATOR_SOURCE)
        draw.set_source_rgb(*self.color[:3]) # premultiplied alpha will give darkening effect
        draw.new_path()
        draw.rectangle(cell_rect.x, cell_rect.y, cell_rect.width, cell_rect.height)
        draw.fill()
        if flags == Gtk.CellRendererState.SELECTED :
            draw.set_operator(cairo.OPERATOR_XOR)
            draw.set_line_width(2)
            # following are default anyway
            # draw.set_dash([])
            # draw.set_line_cap(cairo.LINE_CAP_BUTT)
            # draw.set_line_join(cairo.LINE_JOIN_MITER)
            draw.new_path()
            draw.rectangle(cell_rect.x, cell_rect.y, cell_rect.width, cell_rect.height)
            draw.stroke()
        #end if
    #end do_render

    def do_activate(self, the_event, event_target, location_path, background_rect, cell_rect, flags) :
        pass
    #end do_activate

#end ColorCellRenderer

def msg_alert(msg, type) :
    """displays a simple alert message with an OK button."""
    the_dialog = Gtk.MessageDialog \
      (
        flags = Gtk.DialogFlags.MODAL,
        buttons = Gtk.ButtonsType.OK,
        type = type,
        message_format = msg
      )
    response = the_dialog.run()
    the_dialog.destroy()
#end msg_alert

def error_alert(msg) :
    """displays a simple modal alert error message box."""
    msg_alert(msg, Gtk.MessageType.ERROR)
#end error_alert

def choose_open_file(prompt, filters) :
    """lets the user choose a file matching the specified filters, returning
    its pathname on success or None if user cancelled."""
    the_dialog = Gtk.FileChooserDialog \
      (
        title = prompt,
        action = Gtk.FileChooserAction.OPEN,
        buttons = ("OK", Gtk.ResponseType.OK, "Cancel", Gtk.ResponseType.CANCEL)
      )
    for name, pats in filters :
        the_filter = Gtk.FileFilter()
        the_filter.set_name(name)
        for pat in pats :
            the_filter.add_pattern(pat)
        #end for
        the_dialog.add_filter(the_filter)
    #end for
    response = the_dialog.run()
    if response == Gtk.ResponseType.OK :
        chosen_filename = the_dialog.get_filename()
    else :
        chosen_filename = None
    #end if
    the_dialog.destroy()
    return chosen_filename
#end choose_open_file

def forget_button_blink() :
    if main_window.button_blink_task != None :
        GLib.source_remove(main_window.button_blink_task)
        main_window.button_blink_task = None
    #end if
    main_window.button_selected = False
#end forget_button_blink

def blink_highlighted_button() :
    forget_button_blink()
    main_window.button_blink_task = GLib.timeout_add \
      (
        int(round(select_delay * 1000)),
        button_selection_done
      )
    main_window.button_selected = True
    display_image()
#end blink_highlighted_button

#+
# Global Data
#-

class main_window :
    # window -- Gtk.Window object for main window
    # button_blink_task -- if not None, the current transient task (created by GLib.timeout_add)
    #     for blinking the current button between selected and highlighted states
    # button_selected -- indicates whether the current highlighted button should be shown
    #     in its selected state or not
    # button_list -- a Gtk.ListStore for holding information about defined menu buttons
    # button_highlight_rect -- if not None, a 4-tuple defining the bounds of the
    #     current highlighted menu button
    # image_display -- a Gtk.Image for showing the image
    # image_click -- a Gtk.EventBox for capturing clicks on the image
    # layer_list -- a Gtk.ListStore for holding information about layers in the SVG document
    # layer_display -- a Gtk.TreeView for displaying the contents of layer_list
    # loading -- reentrancy flag to suspend processing of color_display_changed
    # color_button_group -- the radio button group for buttons selecting which image state to show
    # colors_normal_list, colors_highlighted_list, colors_selected_list -- Gtk.ListStore objects
    #     holding the colour tables for the respective image states
    # status_msg -- a Label for showing a status message
    pass
#end main_window

class loaded_image :
    # contents -- parsed XML contents of image file
    # filename -- pathname of image file
    # rowstride -- number of bytes per row of image
    # image_draw_size -- scaled image (width, height) tuple
    # srcdimension -- source image (width, height) tuple
    # widescreen -- whether image is widescreen
    # layers -- dict indexed by layer ID, each entry is dict with "visible" entry
    # indexed_image -- pixel array representing indexed version of image
    # colors -- original colour table for indexed image
    # color_showing -- index [1 .. 4] of colour table to use to show indexed image,
    #     or 0 to show original full-colour image
    pass
#end loaded_image

#+
# Image management
#-

def image_as_svg() :
    """returns the loaded image in SVG textual form."""
    return XMLElementTree.tostring(loaded_image.contents.getroot(), "utf-8")
#end image_as_svg

def render_image_pix() :
    """allocates an array object and fills it with a pixel representation of the
    loaded image."""
    pixels = array.array \
      (
        "B",
            (0, 0, 0, 0) # for correct treatment of non-opaque image pixels
        *
            (loaded_image.rowstride // 4 * loaded_image.image_draw_size[1])
      )
    offscreenpix = cairo.ImageSurface.create_for_data \
      (
        pixels, # data
        cairo.FORMAT_ARGB32, # format
        loaded_image.image_draw_size[0], # width
        loaded_image.image_draw_size[1], # height
        loaded_image.rowstride # stride
      )
    offscreen = cairo.Context(offscreenpix)
    offscreen.identity_matrix()
    scale_factor = min \
      (
        loaded_image.image_draw_size[0] / loaded_image.srcdimensions[0],
        loaded_image.image_draw_size[1] / loaded_image.srcdimensions[1],
      ) # make sure it's all visible
    offscreen.scale(scale_factor, scale_factor)
    svg = Rsvg.Handle.new_from_data(image_as_svg())
    svg.render_cairo(offscreen)
    offscreenpix.flush()
    return pixels
#end render_image_pix

def analyze_image() :
    """hides the button layer and determines what colours are present in the rest
    of the image."""
    loaded_image.image_draw_size = ((480, 360), (640, 360))[loaded_image.widescreen]
    if hasattr(cairo, "format_stride_for_width") :
        loaded_image.rowstride = cairo.format_stride_for_width \
          (
            cairo.FORMAT_ARGB32,
            loaded_image.image_draw_size[0]
          )
    else :
        loaded_image.rowstride = loaded_image.image_draw_size[0] * 4
    #end if
    selected_layer_id = get_single_list_selection(main_window.layer_display, 1)
    for layer in loaded_image.contents.findall("{%s}g" % ns.svg) :
        layer_id = layer.get("id")
        if layer_id in loaded_image.layers :
            layer.set \
              (
                "style",
                    "display:"
                +
                    ("none", "inline")
                        [layer_id != selected_layer_id and loaded_image.layers[layer_id]["visible"]]
                          # set button layer to invisible, restore visibility of rest to
                          # original state
              )
        #end if
    #end for
    loaded_image.indexed_image, loaded_image.colors = \
        spuhelper.index_image(render_image_pix(), color_approx_count_factor)
    loaded_image.color_showing = 0
    if loaded_image.indexed_image == None :
        if True : # debug
            pix_total = 0
            for color in loaded_image.colors :
                pix_total += color[1]
            #end for
            debug_colors = tuple((color, freq / pix_total) for color, freq in loaded_image.colors[:4])
            top_total = 0
            for color in debug_colors :
                top_total += color[1]
            #end for
            sys.stderr.write("top colours: %s = %.3f\n" % (repr(debug_colors), top_total)) # debug
        #end if
        msg = \
            (
                "<span foreground=\"#FF0000\">%d colours is too many, mustn't exceed 4</span>"
            %
                len(loaded_image.colors)
            )
        use_colors = ()
    else :
        msg = ""
        main_window.loading = True # suspend triggering of color_display_changed
        for button in main_window.color_button_group.get_group() :
            index = button.dvd_menu_index
            button.set_active(index == 0)
            button.set_sensitive(True)
        #end for
        main_window.loading = False
    #end if
    use_colors = loaded_image.colors
    for \
        color_list \
    in \
        (
            main_window.colors_normal_list,
            main_window.colors_highlighted_list,
            main_window.colors_selected_list,
        ) \
    :
        color_list.clear()
        for color in use_colors :
            color_list.append((color[0],))
        #end for
        use_colors = use_colors[:4] # no more than 4 for highlighted & selected lists
    #end for
    main_window.status_msg.set_markup(msg)
#end analyze_image

def display_image() :
    """(re)displays the currently-loaded SVG image."""
    if loaded_image.contents != None :
        highlight_pixels = None # to begin with
        if loaded_image.color_showing == 0 :
            image_pixels = render_image_pix()
        else :
            color_list = \
                (
                    main_window.colors_normal_list,
                    main_window.colors_highlighted_list,
                    main_window.colors_selected_list,
                    main_window.colors_normal_list
                )[loaded_image.color_showing - 1]
            colors = tuple(color[0] for color in color_list)
            image_pixels = spuhelper.expand_image(loaded_image.indexed_image, colors)
            if main_window.button_highlight != None and loaded_image.color_showing == 4 :
                highlight_pixels = spuhelper.expand_image \
                  (
                    loaded_image.indexed_image,
                    tuple
                      (
                        color[0]
                        for color in
                            (
                                main_window.colors_highlighted_list,
                                main_window.colors_selected_list
                            )[main_window.button_selected]
                      )
                  )
            #end if
        #end if
        light, dark = 0xFFD6D6D6, 0xFFACACAC
          # same colours that Gtk.ColorSelection uses for background of opacity display
        pattern_array = array.array \
          (
            "I",
                16 * (16 * (light,) + 16 * (dark,))
            +
                16 * (16 * (dark,) + 16 * (light,))
          )
        check_pattern = cairo.SurfacePattern \
          (
            cairo.ImageSurface.create_for_data
              (
                pattern_array, # data
                cairo.FORMAT_ARGB32, # format
                32, # width
                32, # height
                32 * 4 # stride
              )
          ) # to show through less-than-fully-opaque pixels
        check_pattern.set_extend(cairo.EXTEND_REPEAT)
        display_pixels = array.array \
          (
            "B", # not "I" because then tostring puts the bytes in the wrong order--does this still matter?
            (255, 255, 255, 255) * loaded_image.image_draw_size[1] * (loaded_image.rowstride // 4)
              # initial colour doesn't matter, will be replaced by check_pattern
          )
        composite_surface = cairo.ImageSurface.create_for_data \
          (
            display_pixels, # data
            cairo.FORMAT_ARGB32, # format
            loaded_image.image_draw_size[0], # width
            loaded_image.image_draw_size[1], # height
            loaded_image.rowstride # stride
          )
        composite = cairo.Context(composite_surface)
        composite.set_source(check_pattern)
        composite.paint()
        if loaded_image.background != None :
            background_pattern = cairo.SurfacePattern(loaded_image.background)
            background_pattern.set_matrix \
              (
                rect_matrix
                  (
                    (0, 0) + loaded_image.image_draw_size,
                    (0, 0, loaded_image.background.get_width(), loaded_image.background.get_height())
                  )
              ) # distort as necessary to fit dimensions of menu
            composite.set_source(background_pattern)
            composite.paint()
        #end if
        composite.set_source_surface \
          (
            cairo.ImageSurface.create_for_data
              (
                image_pixels, # data
                cairo.FORMAT_ARGB32, # format
                loaded_image.image_draw_size[0], # width
                loaded_image.image_draw_size[1], # height
                loaded_image.rowstride # stride
              )
          )
        composite.paint()
        if highlight_pixels != None :
            composite.set_source_surface \
              (
                cairo.ImageSurface.create_for_data
                  (
                    highlight_pixels, # data
                    cairo.FORMAT_ARGB32, # format
                    loaded_image.image_draw_size[0], # width
                    loaded_image.image_draw_size[1], # height
                    loaded_image.rowstride # stride
                  )
              )
            composite.rectangle(*main_window.button_highlight_rect)
            composite.fill()
        #end if
        composite_surface.flush()
        main_window.image_display.set_from_surface(composite_surface)
    #end if
#end display_image

def load_menu_image(filename) :
    """loads a new SVG image file and also collects various useful information about it."""
    try :
        try :
            new_contents = XMLElementTree.parse(filename)
        except ExpatError :
            raise Failure("Not a valid SVG file.")
        except IOError as why :
            raise Failure(str(why))
        #end try
        new_layers = {}
        new_layer_list = []
        svg_tag = new_contents.getroot()
        new_src_dimensions = (get_svg_length(svg_tag, "width")[0], get_svg_length(svg_tag, "height")[0])
          # note I don't care what the units are, I'm just assuming they're the same
        aspect_ratio = new_src_dimensions[0] / new_src_dimensions[1]
        aspect_tolerance = 0.05 # give user some room to be sloppy
        if abs(aspect_ratio / 4 * 3 - 1) <= aspect_tolerance :
            widescreen = False
        elif abs(aspect_ratio / 16 * 9 - 1) <= aspect_tolerance :
            widescreen = True
        else :
            raise Failure("Image dimensions cannot be approximated as either 4:3 or 16:9")
        #end if
        for layer in new_contents.findall("{%s}g" % ns.svg) :
            if layer.get("{%s}groupmode" % ns.inkscape) == "layer" :
                layer_id = layer.get("id")
                new_layers[layer_id] = \
                    {
                        "visible" : layer.get("style") != "display:none",
                          # save initial visibility state
                          # Assumption: Inkscape only sets style attribute to "display:inline"
                          # for visible layers and "display:none" for invisible ones
                    }
                new_layer_list.append \
                  (
                    (layer.get("{%s}label" % ns.inkscape), layer_id)
                  )
            #end if
        #end for
        if len(new_layer_list) == 0 :
            raise Failure("No layers found in document. Are you sure it was created by Inkscape?")
        #end if
        if len(new_layer_list) == 1 :
            raise Failure("Need at least 2 layers, one for buttons and the rest for the image.")
        #end if
        # passed all validation checks
        main_window.loading = True # suspend triggering of color_display_changed
        loaded_image.filename = filename
        loaded_image.contents = new_contents
        loaded_image.srcdimensions = new_src_dimensions
        loaded_image.widescreen = widescreen
        main_window.layer_list.clear()
        for layer in new_layer_list :
            main_window.layer_list.append(layer)
        #end for
        loaded_image.layers = new_layers
        main_window.layer_display.get_selection().select_path((len(main_window.layer_list) - 1,))
          # default to using top layer as buttons
        loaded_image.color_showing = 0
        for button in main_window.color_button_group.get_group() :
            index = button.dvd_menu_index
            button.set_active(index == 0)
            button.set_sensitive(index == 0)
        #end for
        main_window.loading = False
        forget_button_blink()
        analyze_image()
        display_image()
    except Failure as reason :
        error_alert(reason.msg)
    #end try
#end load_menu_image

def load_background_image(filename) :
    """loads a new background image."""
    try :
        try :
            image_pixbuf = GdkPixbuf.Pixbuf.new_from_file(filename)
        except GLib.GError as why :
            raise Failure(str(why))
        #end try
        image_pix_array = spuhelper.gtk_to_cairo_a(image_pixbuf)
          # I would like to get rid of this spuhelper routine, but there
          # seems to be no easy way to construct a Cairo surface from
          # non-PNG image formats like JPEG. Or could I create a
          # temporary Gtk.Image and get a surface from that?
        loaded_image.background = cairo.ImageSurface.create_for_data \
          (
            image_pix_array, # data
            cairo.FORMAT_ARGB32, # format
            image_pixbuf.get_property("width"), # width
            image_pixbuf.get_property("height"), # height
            image_pixbuf.get_property("width") * 4 # stride
          )
        forget_button_blink()
        display_image()
    except Failure as reason :
        error_alert(reason.msg)
    #end try
#end load_background_image

def load_colors(palette_filename) :
    """loads a palette file of colours to choose from."""
    try :
        try :
            palette_file = open(palette_filename, "r")
        except IOError as why :
            raise Failure(str(why))
        #end try
        if palette_file.readline().strip() != "GIMP Palette" :
            raise Failure("doesn't look like a GIMP palette file")
        #end if
        name = "Untitled"
        while True :
            line = palette_file.readline()
            if len(line) == 0 :
                raise Failure("palette file seems to be empty")
            #end if
            line = line.rstrip("\n")
            if line.startswith("Name: ") :
                name = line[6:].strip()
            #end if
            if line.startswith("#") :
                break
        #end while
        colors = []
        while True :
            line = palette_file.readline()
            if len(line) == 0 :
                break
            if not line.startswith("#") :
                line = line.rstrip("\n")
                components = line.split("\t", 1)
                if len(components) == 1 :
                    components.append("") # empty name
                #end if
                try :
                    color = tuple(int(i.strip()) for i in components[0].split(None, 2))
                except ValueError :
                    raise Failure("bad colour on line %s" % repr(line))
                #end try
                colors.append((color, components[1]))
            #end if
        #end while
      # all successfully loaded
        main_window.loaded_colors_list.clear()
        for color in colors :
            main_window.loaded_colors_list.append((color[0],)) # fixme display name as well
        #end for
        main_window.loaded_colors_display.get_column(0).set_title(name)
    except Failure as reason :
        error_alert(reason.msg)
    #end try
#end load_colors

def load_saved_colors(menu_filename) :
    """reloads the colour palettes from a previously-saved menu XML file."""
    try :
        try :
            menu_contents = XMLElementTree.parse(menu_filename)
        except ExpatError :
            raise Failure("Not a valid XML file.")
        #end try
        find_tag = menu_contents.getroot()
        if find_tag != None :
            find_tag = find_tag.find("stream")
        #end if
        if find_tag != None :
            find_tag = find_tag.find("spu")
        #end if
        if find_tag == None :
            raise Failure("can't make sense of contents of menu XML file")
        #end if
        succeeded = []
        failed = []
        for \
            description, attr, color_list \
        in \
            (
                ("normal", "image", main_window.colors_normal_list),
                ("highlighted", "highlight", main_window.colors_highlighted_list),
                ("selected", "select", main_window.colors_selected_list),
            ) \
        :
            image_name = find_tag.get(attr)
            if image_name != None :
                try :
                    if not image_name.startswith("/") :
                        image_name = os.path.join(os.path.dirname(menu_filename), image_name)
                    #end if
                    try :
                        image_file = open(image_name, "rb")
                    except IOError :
                        raise Failure("couldn't open %s" % image_name)
                    #end try
                    try :
                        sys.stderr.write("getting colours from %s\n" % repr(image_file)) # debug
                        colors = spuhelper.read_png_palette(image_file)
                    except RuntimeError :
                        raise Failure("couldn't make sense of %s" % image_name)
                    #end try
                    if colors == None :
                        raise Failure("no palette in PNG file %s" % image_name)
                    #end if
                    for i, color in enumerate(colors[:4]) :
                        color_list.set_value(color_list.get_iter((i,)), 0, color)
                    #end for
                    succeeded.append(description)
                except Failure :
                    failed.append(image_name)
                #end try
            #end if
        #end for
        msg = \
            (
                ("", "Successfully loaded: ")[len(succeeded) != 0]
            +
                ", ".join(succeeded)
            +
                ("", "; ")[len(succeeded) != 0 and len(failed) != 0]
            +
                ("", "failed to load: ")[len(failed) != 0]
            +
                ", ".join(failed)
            +
                ("", ".")[len(succeeded) != 0 or len(failed) != 0]
            )
        msg_alert(msg, Gtk.MessageType.INFO)
    except Failure as reason :
        error_alert(reason.msg)
    #end try
#end load_saved_colors

def find_buttons() :
    """finds all button definitions in the selected button layer."""
    the_layer = None # initial assumption
    selected_layer_id = get_single_list_selection(main_window.layer_display, 1)
    if selected_layer_id != None :
        for layer in loaded_image.contents.findall("{%s}g" % ns.svg) :
            if layer.get("id") == selected_layer_id :
                the_layer = layer
                break
            #end if
        #end for
    #end if
    main_window.button_list.clear()
    if the_layer != None :
        for button in the_layer.findall("{%s}rect" % ns.svg) :
            button_name = button.get("id")
            button_info = \
                {
                    "bounds" :
                        (
                            float(button.get("x")),
                            float(button.get("y")),
                            float(button.get("width")),
                            float(button.get("height")),
                        ),
                }
            desc = button.find("{%s}desc" % ns.svg)
            if desc != None :
                for entry in desc.text.split("\n") :
                    entry = entry.split("=", 1)
                    if len(entry) == 2 :
                        key, value = entry
                        if key == "action" :
                            button_info["auto"] = value == "auto"
                        elif key in ("up", "down", "left", "right") :
                            button_info[key] = value
                        #end if
                    #end if
                #end for
            #end if
            main_window.button_list.append((button_name, button_info))
        #end for
    #end if
#end find_buttons()

#+
# GUI callbacks
#-

def destroy_window(the_window) :
    # called when main window's close box is clicked.
    Gtk.main_quit()
#end destroy_window

def select_load_menu_image(the_window) :
    # lets the user choose an SVG file to load for the menu image.
    image_filename = choose_open_file \
      (
        prompt = "Choose SVG Image for Menu",
        filters = (("SVG Files", ("*.svg",)),)
      )
    if image_filename != None :
        load_menu_image(image_filename)
    #end if
#end select_load_menu_image

def select_load_background_image(the_window) :
    # lets the user choose a JPEG or PNG file to load for the background image.
    if loaded_image.contents == None :
        error_alert("Load the menu image first.")
          # because I'm not currently showing the background otherwise
    else :
        image_filename = choose_open_file \
          (
            prompt = "Choose JPEG or PNG Image for Background",
            filters =
                (
                    ("JPEG Files", ("*.jpg", "*.jpeg")),
                    ("PNG Files", ("*.png",)),
                )
          )
        if image_filename != None :
            load_background_image(image_filename)
        #end if
    #end if
#end select_load_background_image

def select_load_colors(the_window) :
    # lets the user choose a palette file of colours to choose from.
    palette_filename = choose_open_file \
      (
        prompt = "Choose Palette File to Load",
        filters = (("GIMP Palette Files", ("*.gpl",)),)
      )
    if palette_filename != None :
        load_colors(palette_filename)
    #end if
#end select_load_colors

def select_load_saved_colors(the_window) :
    # lets the user choose a previously-saved menu XML file from which to reload
    # the colour palettes.
    menu_filename = choose_open_file \
      (
        prompt = "Choose Previously-Saved Menu File to Load",
        filters = (("XML Files", ("*.xml",)),)
      )
    if menu_filename != None :
        load_saved_colors(menu_filename)
    #end if
#end select_load_saved_colors

def layer_selection_changed(the_selection) :
    # called on a change to the selection of the button layer.
    forget_button_blink()
    find_buttons()
    analyze_image()
    display_image()
#end layer_selection_changed

def color_display_changed(the_button, index) :
    if not main_window.loading and the_button.get_active() :
        loaded_image.color_showing = index
        forget_button_blink()
        display_image()
    #end if
#end color_display_changed

def edit_color(tree_view, color_path, view_column) :
    # called when an item in a colour list is double-clicked.
    forget_button_blink()
    if color_path[0] < 4 : # excess colours won't be saved anyway
        color_list = tree_view.get_model()
        the_color = color_list.get_value(color_list.get_iter(color_path), 0)
        choose_new_color = Gtk.ColorSelectionDialog(title = "Choose a colour, any colour")
          # note: seems this is now deprecated -- should it be replaced by
          # GtkColorChooserDialog <https://developer.gnome.org/gtk3/stable/GtkColorChooserDialog.html>?
        chooser = choose_new_color.get_color_selection()
        chooser.set_has_opacity_control(True)
        if the_color[3] != 0 : # convert from premultiplied alpha
            chooser.set_current_rgba \
              (
                Gdk.RGBA(*(tuple((i / the_color[3] for i in the_color[:3])) + (the_color[3],)))
              )
        else :
            chooser.set_current_rgba(Gdk.RGBA(0, 0, 0, 0))
        #end if
        response = choose_new_color.run()
        if response == choose_new_color.get_response_for_widget(choose_new_color.get_property("ok-button")) :
            new_color = chooser.get_current_color()
            opacity = chooser.get_current_alpha() >> 8
            new_color = \
                ( # convert to premultiplied alpha
                    new_color.red // 257 * opacity // 255,
                    new_color.green // 257 * opacity // 255,
                    new_color.blue // 257 * opacity // 255,
                    opacity,
                )
            color_list.set_value(color_list.get_iter(color_path), 0, new_color)
            display_image()
        #end if
        choose_new_color.destroy()
    #end if
#end edit_color

def drag_get_color(color_list, drag_context, selection_data, info_id, timestamp) :
    # called on a drag to retrieve the colour spec from the drag source.
    the_color = get_single_list_selection(color_list, 0)
    if the_color != None :
        the_color = ",".join(str(i) for i in the_color)
    else :
        the_color = ""
    #end if
    selection_data.set_text(the_color, -1)
#end drag_get_color

def drag_set_color(color_list, drag_context, drop_x, drop_y, selection_data, info_id, timestamp) :
    # called on a drag to save the colour spec into the drag destination.
    drop_y -= color_list.get_cell_area((0,), color_list.get_column(0)).height
      # FUDGE: GTK bug? seems to pass Y-coordinate from top of column heading,
      # not from top of first cell
    the_color = selection_data.get_text()
    the_path = color_list.get_path_at_pos(drop_x, drop_y)
    if the_path != None and the_color != "" :
        the_path = the_path[0]
        if the_path[0] < 4 :
            list_model = color_list.get_model()
            the_row = list_model.get_iter(the_path)
            the_color = tuple(int(i) for i in the_color.split(","))
            if len(the_color) < 4 :
                # no new opacity, preserve existing setting
                the_color = the_color + (list_model.get_value(the_row, 0)[3],)
            #end if
            list_model.set_value(the_row, 0, the_color)
            display_image()
        #end if
    #end if
#end drag_set_color

def button_selection_done() :
    # timeout callback to turn off display of button in selected state
    main_window.button_blink_task = None
    main_window.button_selected = False
    display_image()
    return False # one-off invocation
#end button_selection_done

def image_click_event(the_widget, the_event) :
    handled = False
    if loaded_image.color_showing == 4 :
        if the_event.type == Gdk.EventType.BUTTON_PRESS :
            main_window.image_click.grab_focus()
        elif the_event.type == Gdk.EventType.BUTTON_RELEASE :
            pass
            # handled = True
        elif the_event.type == Gdk.EventType.FOCUS_CHANGE :
            if not the_event.in_ :
                forget_button_blink()
                if main_window.button_highlight != None :
                    main_window.button_highlight = None
                    display_image()
                #end if
            #end if
            # handled = True
        elif the_event.type == Gdk.EventType.KEY_PRESS :
            if False :
                sys.stderr.write \
                  (
                    "key press state = %d, val = %s\n" % (the_event.state, repr(the_event.keyval))
                  ) # debug
            #end if
            navigation = \
                {
                    keyval.upkey : "up",
                    keyval.downkey : "down",
                    keyval.leftkey : "left",
                    keyval.rightkey : "right",
                }
            if the_event.keyval in (keyval.returnkey, keyval.enterkey) :
                blink_highlighted_button()
            elif the_event.keyval in navigation and main_window.button_highlight != None :
                next_button_id = main_window.button_highlight.get(navigation[the_event.keyval])
                next_button = None
                if next_button_id != None :
                    for button in iter(main_window.button_list) :
                        if button[0] == next_button_id :
                            next_button = button
                        #end if
                    #end for
                #end if
                if next_button != None :
                    forget_button_blink()
                    main_window.button_highlight = next_button[1]
                    main_window.button_highlight_rect = map_button \
                      (
                        bounds = next_button[1]["bounds"],
                        srcdimensions = loaded_image.srcdimensions,
                        dstdimensions = loaded_image.image_draw_size
                      )
                    display_image()
                #end if
            #end if
            handled = True
        #end if
        if the_event.type == Gdk.EventType.BUTTON_PRESS or the_event.type == Gdk.EventType.MOTION_NOTIFY :
            # do buttons in reverse order to pick up topmost one
            button_index = len(main_window.button_list)
            while True :
                if button_index == 0 :
                    this_button = None
                    break
                #end if
                button_index -= 1
                this_button = main_window.button_list[button_index][1]
                bounds = this_button["bounds"]
                bounds = map_button \
                  (
                    bounds = bounds,
                    srcdimensions = loaded_image.srcdimensions,
                    dstdimensions = loaded_image.image_draw_size
                  )
                if (
                        the_event.x >= bounds[0]
                    and
                        the_event.x < bounds[0] + bounds[2]
                    and
                        the_event.y >= bounds[1]
                    and
                        the_event.y < bounds[1] + bounds[3]
                ) :
                    break
                #end if
            #end while
            if this_button != main_window.button_highlight :
                forget_button_blink()
                main_window.button_highlight = this_button
                main_window.button_highlight_rect = bounds
                display_image()
            #end if
            # handled = True
        #end if
        if the_event.type == Gdk.EventType._2BUTTON_PRESS :
            if main_window.button_highlight != None :
                blink_highlighted_button()
            #end if
            # handled = True
        #end if
    #end if
    return handled
#end image_click_event

def select_save_menu(the_window) :
    # lets the user specify a file name for saving the completely-built
    # spumux control file and associated menu image files.

    the_dialog = None
    normal_label_style = None
    dimmed_label_style = None
    name_labels = {}
    extra_filenames = {}
    selected_aspects = [None, None]
    generate_menu = [True, True] # whether to generate narrowscreen and widescreen versions of menu
    class context :
        synchronize_task = None
    #end context

    def selected_aspect_toggled(the_button, which) :
        generate_menu[which] = the_button.get_active()
        for \
            suffix \
        in \
            (
                ((), ("letterbox",))["letterbox" in extra_filenames and which]
            +
                tuple(s + ("", "-letterboxed")[which] for s in ("normal", "highlighted", "selected"))
            ) \
        :
            for name_label in (extra_filenames[suffix], name_labels[suffix]) :
                name_label.modify_style((dimmed_label_style, normal_label_style)[generate_menu[which]])
            #end for
        #end for
    #end selected_aspect_toggled

    def synchronize_names(base_filename) :
        # synchronizes all automatically-generated file names with the one
        # manually typed by the user.
        if base_filename == None :
            base_filename = os.path.splitext(os.path.basename(the_dialog.get_filename()))[0]
        #end if
        if "letterbox" in extra_filenames :
            extra_filenames["letterbox"].set_text("%s-letterboxed.xml" % (base_filename,))
            for suffix in ("normal-letterboxed", "highlighted-letterboxed", "selected-letterboxed") :
                extra_filenames[suffix].set_text("%s-%s.png" % (base_filename, suffix))
            #end for
        #end if
        for suffix in ("normal", "highlighted", "selected") :
            extra_filenames[suffix].set_text("%s-%s.png" % (base_filename, suffix))
        #end for
        return False # one-off timeout invocation
    #end synchronize_names

    def forget_synchronize() :
        # loses the synchronization task, if it hasn't triggered yet
        if context.synchronize_task != None :
            GLib.source_remove(context.synchronize_task)
            context.synchronize_task = None
        #end if
    #end forget_synchronize

    def save_key_press(the_widget, the_event) :
        # intercepts user text entry for the saved filename to keep the
        # other generated filenames in sync.
        if the_event.type == Gdk.EventType.KEY_PRESS :
            if False :
                sys.stderr.write \
                  (
                    "save_key_press state = %d, val = %s\n" % (the_event.state, repr(the_event.keyval))
                  ) # debug
            #end if
            # Need to call synchronize_names _after_ the file chooser has processed this
            # keystroke. Only I way I can think of to get control at that point is by
            # a delayed task.
            forget_synchronize()
            context.synchronize_task = GLib.timeout_add \
              (
                int(round(0.1 * 1000)),
                synchronize_names,
                None
              )
        #end if
    #end save_key_press

#begin select_save_menu
    if loaded_image.contents != None :
        the_dialog = Gtk.FileChooserDialog \
          (
            title = "Save Menu As:",
            action = Gtk.FileChooserAction.SAVE,
            buttons = ("Save", Gtk.ResponseType.OK, "Cancel", Gtk.ResponseType.CANCEL)
          )
        extra_box = Gtk.Table \
          (
            rows = (4, 9)[loaded_image.widescreen],
            columns = 4, # extra columns just to get cell sizes looking right
            homogeneous = True
          )
        format_row = (3, 9)[loaded_image.widescreen]
        if loaded_image.widescreen :
            # allow user to save 2 separate menu XML files with associated
            # image files, one which displays full-height on all screens and
            # one which displays letterboxed on 4:3 screens
            extra_names_prompts = \
                {
                    "normal" : "Normal Image (Full-Height): ",
                    "highlighted" : "Highlighted Image (Full-Height): ",
                    "selected" : "Selected Image (Full-Height): ",
                    "letterbox" : "Letterboxed Menu: ",
                    "normal-letterboxed" : "Normal Image (Letterboxed): ",
                    "highlighted-letterboxed" : "Highlighted Image (Letterboxed): ",
                    "selected-letterboxed" : "Selected Image (Letterboxed): ",
                }
            selected_aspects[False] = Gtk.CheckButton(label = "Save Full-Height Version")
            selected_aspects[False].set_active(True) # not default
            selected_aspects[False].connect("toggled", selected_aspect_toggled, False)
            selected_aspects[True] = Gtk.CheckButton(label = "Save Letterboxed Version")
            selected_aspects[True].set_active(True) # not default
            selected_aspects[True].connect("toggled", selected_aspect_toggled, True)
            extra_box.attach \
              (
                selected_aspects[False],
                0, 2, 0, 1
              )
            extra_box.attach \
              (
                selected_aspects[True],
                0, 2, 4, 5
              )
        else :
            extra_names_prompts = \
                {
                    "normal" : "Normal Image: ",
                    "highlighted" : "Highlighted Image: ",
                    "selected" : "Selected Image: ",
                }
        #end if
        for \
                row, suffix \
            in \
                enumerate \
                  (
                        (
                            (),
                            (None,), # checkbox goes here (above)
                        )[loaded_image.widescreen]
                    +
                        ("normal", "highlighted", "selected")
                    +
                        (
                            (),
                            (
                                None, # checkbox goes here (above)
                                "letterbox",
                                "normal-letterboxed",
                                "highlighted-letterboxed",
                                "selected-letterboxed",
                            )
                        )[loaded_image.widescreen]
                  ) \
        :
            if suffix != None :
                name_labels[suffix] = Gtk.Label(extra_names_prompts[suffix])
                name_labels[suffix].set_alignment(0, 0.5)
                extra_box.attach \
                  (
                    name_labels[suffix],
                    0, 1, row, row + 1
                  )
                extra_filenames[suffix] = Gtk.Label()
                extra_filenames[suffix].set_alignment(0, 0.5)
                if normal_label_style == None :
                    extra_filenames[suffix].ensure_style()
                    normal_label_style = extra_filenames[suffix].get_style()
                #end if
                extra_box.attach \
                  (
                    extra_filenames[suffix],
                    1, 2, row, row + 1
                  )
            #end if
        #end if
        dimmed_label_style = Gtk.RcStyle()
        if False :
            # FIXME: Cannot get this to work. Access to .fg triggers
            # “CRITICAL **: Stack overflow protection. Can't copy array element into GIArgument.”
            # message and I get a 0-length list.
            for state in (Gtk.StateFlags.NORMAL,) : # no need for Gtk.StateFlags.INSENSITIVE
                the_color = Gdk.RGBA.from_color(normal_label_style.fg[state])
                the_color = colorsys.rgb_to_hsv(the_color.red, the_color.green, the_color.blue)
                the_color = colorsys.hsv_to_rgb \
                  (
                    the_color[0],
                    the_color[1] / 2,
                    1.0 - (1.0 - the_color[2]) / 2
                  )
                dimmed_label_style.fg[state] = \
                    Gdk.RGBA(the_color[0], the_color[1], the_color[2]).to_color()
            #end for
        #end if
        normal_label_style = Gtk.RcStyle() # with no customizations # fixme: not used
        name_label = Gtk.Label("Video Format: ")
        name_label.set_alignment(0, 0.5)
        extra_box.attach \
          (
            name_label,
            0, 1, format_row, format_row + 1
          )
        format_selector = Gtk.ComboBoxText()
        default_video_format = get_default_video_format()
        for i, video_format in enumerate(sorted(valid_video_formats)) :
            format_selector.append_text(video_format)
            if video_format == default_video_format :
                format_selector.set_active(i)
            #end if
        #end for
        extra_box.attach \
          (
            format_selector,
            1, 2, format_row, format_row + 1
          )
        extra_box.show_all()
        the_dialog.set_extra_widget(extra_box)
        the_dialog.connect("key-press-event", save_key_press)
        base_filename = os.path.splitext(os.path.basename(loaded_image.filename))[0]
        the_dialog.set_current_name(base_filename + ".xml")
        synchronize_names(base_filename)
          # need to pass base_filename because the_dialog.get_filename() returns None at this point
        menu_filenames = [None, None]
        generate_menu[True] = loaded_image.widescreen
        while True :
            response = the_dialog.run()
            forget_synchronize()
            if response != Gtk.ResponseType.OK :
                break
            #end if
            synchronize_names(None)
            try : # validate user selection
                if not (generate_menu[False] or generate_menu[True]) :
                    raise Failure("Nothing to do!")
                #end if
                video_format = format_selector.get_active_text()
                if video_format not in ("NTSC", "PAL") :
                    raise Failure("You must choose a video format.")
                #end if
                parent_dir = os.path.dirname(the_dialog.get_filename())
                image_names = {}
                if generate_menu[False] :
                    menu_filenames[False] = the_dialog.get_filename()
                    for suffix in ("normal", "highlighted", "selected") :
                        image_names[suffix] = os.path.join(parent_dir, extra_filenames[suffix].get_text())
                    #end for
                #end if
                if generate_menu[True] :
                    menu_filenames[True] = os.path.join \
                      (
                        parent_dir,
                        extra_filenames["letterbox"].get_text()
                      )
                    for suffix in ("normal-letterboxed", "highlighted-letterboxed", "selected-letterboxed") :
                        image_names[suffix] = os.path.join(parent_dir, extra_filenames[suffix].get_text())
                    #end for
                #end if
                overwriting = list \
                  (
                    os.path.basename(f)
                        for f in tuple(menu_filenames) + tuple(image_names.values())
                        if f != None and os.path.exists(f)
                  )
                if len(overwriting) == 0 :
                    break
                confirm_dialog = Gtk.MessageDialog \
                  (
                    flags = Gtk.DialogFlags.MODAL,
                    buttons = Gtk.ButtonsType.OK_CANCEL,
                    type = Gtk.MessageType.QUESTION,
                    message_format =
                        "File(s) already exist: %s. Overwrite?" % ", ".join(overwriting)
                  )
                response = confirm_dialog.run()
                confirm_dialog.destroy()
                if response == Gtk.ResponseType.OK :
                    break
            except Failure as reason :
                error_alert(reason.msg)
                # and keep prompting user for save filenames
            #end try
        #end while
        the_dialog.destroy()
        fill_color = loaded_image.colors[0][0] # so leftover pixels get most popular colour
        # convert native-endian Cairo format
        if sys.byteorder == "big" :
            fill_color = (fill_color[3], fill_color[0], fill_color[1], fill_color[2])
        else :
            fill_color = (fill_color[2], fill_color[1], fill_color[0], fill_color[3])
        #end if
        if menu_filenames[False] != None :
            imagebounds = {"NTSC" : (720, 480), "PAL" : (720, 576)}[video_format]
            reference_scale = ((4, 3), (16, 9))[loaded_image.widescreen]
            image_ref_height = imagebounds[0] / reference_scale[0] * reference_scale[1]
              # image height if pixels were square
            image_rowstride = imagebounds[0] * 4 # fixme: use format_stride_for_width
            letterboxed = False # which version of menu I'm generating
            while True : # write menu XML file(s) and associated image files
                if generate_menu[letterboxed] :
                    rgb_pixels = array.array \
                      (
                        "B",
                            (0, 0, 0, 0) # for correct treatment of non-opaque image pixels
                        *
                            (image_rowstride // 4 * imagebounds[1])
                      )
                    rgb_pix = cairo.ImageSurface.create_for_data \
                      (
                        rgb_pixels, # data
                        cairo.FORMAT_ARGB32, # format
                        imagebounds[0], # width
                        imagebounds[1], # height
                        image_rowstride # stride
                      )
                    rgb_render = cairo.Context(rgb_pix)
                    fit_factor = min \
                      (
                        imagebounds[0] / loaded_image.srcdimensions[0],
                        image_ref_height / loaded_image.srcdimensions[1],
                      ) # make sure it's all visible
                    rgb_render.set_matrix \
                      (
                        to_cairo
                          (
                            Matrix.scaling(Point
                              (
                                fit_factor,
                                imagebounds[1] / image_ref_height * fit_factor
                              ))
                          )
                      )
                    svg = Rsvg.Handle.new_from_data(image_as_svg())
                    svg.render_cairo(rgb_render)
                    rgb_pix.flush()
                    if letterboxed :
                        # squeeze menu image down to letterboxed height
                        height_mid = imagebounds[1] / 2
                        half_height = imagebounds[1] / 2 * (9 / 16) / (3 / 4)
                        menu_bounds = \
                            (
                                0,
                                height_mid - half_height,
                                imagebounds[0],
                                2 * half_height
                            )
                        to_middle = Point(0, height_mid)
                        new_render_pixels = array.array \
                          (
                            "B",
                                fill_color
                            *
                                (image_rowstride // 4 * imagebounds[1])
                          )
                        new_render_pix = cairo.ImageSurface.create_for_data \
                          (
                            new_render_pixels, # data
                            cairo.FORMAT_ARGB32, # format
                            imagebounds[0], # width
                            imagebounds[1], # height
                            image_rowstride # stride
                          )
                        new_render = cairo.Context(new_render_pix)
                        new_render.set_operator(cairo.OPERATOR_SOURCE)
                          # ensure correct treatment of non-opaque pixels
                        new_render.rectangle \
                          (
                            0, # x
                            imagebounds[1] / 2 - half_height + 1, # y
                            imagebounds[0], # width
                            2 * half_height - 2 # height
                          )
                          # be sure not to pick up any transparent areas outside
                          # menu image, fudge height a bit to truncate partial
                          # pixels just in case
                        new_render.set_matrix \
                          (
                            to_cairo
                              (
                                    Matrix.translation(- to_middle)
                                *
                                    Matrix.scaling(Point(1, (9 / 16) / (3 / 4)))
                                *
                                    Matrix.translation(to_middle)
                              )
                          )
                        old_render = cairo.SurfacePattern(rgb_pix)
                        old_render.set_filter(cairo.FILTER_NEAREST)
                          # ensure I don't add any new colours
                        new_render.set_source(old_render)
                        new_render.fill()
                        new_render_pix.flush()
                        old_render = None # free up memory
                        rgb_pixels = new_render_pixels
                        rgb_pix = new_render_pix
                        rgb_render = new_render
                    else :
                        menu_bounds = (0, 0) + imagebounds
                    #end if
                    for \
                        colors, suffix \
                    in \
                        (
                            (main_window.colors_normal_list, "normal"),
                            (main_window.colors_highlighted_list, "highlighted"),
                            (main_window.colors_selected_list, "selected"),
                        ) \
                    :
                        # rgb_pix.write_to_png(open(image_names[suffix + ("", "-letterboxed")[letterboxed]] + "-debug.png", "wb")) # debug
                        image_name = image_names[suffix + ("", "-letterboxed")[letterboxed]]
                        colors = tuple(color[0] for color in colors)
                        indexed_image, _ = spuhelper.index_image(rgb_pixels, color_approx_count_factor)
                        out_file = open(image_name, "wb")
                        spuhelper.write_png \
                          (
                            indexed_image, # pixels array
                            imagebounds[0], # width
                            colors,
                            out_file
                          )
                        out_file.flush()
                        out_file.close()
                    #end for
                    subpictures = XMLElementTree.Element \
                      (
                        "subpictures",
                        attrib =
                            {
                                "format" : video_format,
                            }
                      )
                    stream = XMLElementTree.SubElement(subpictures, "stream")
                    spu = XMLElementTree.SubElement \
                      (
                        stream,
                        "spu",
                            {
                                "force" : "yes",
                                # "transparent"?
                                "start" : "00:00:00.0",
                                "end" : "00:00:00.0",
                                "image" : os.path.basename(image_names["normal"]),
                                "highlight" : os.path.basename(image_names["highlighted"]),
                                "select" : os.path.basename(image_names["selected"]),
                            }
                      )
                    for button in iter(main_window.button_list) :
                        button_spec = button[1]
                        bounds = map_button_rect \
                          (
                            button_bounds = button_spec["bounds"],
                            srcbounds = (0, 0) + loaded_image.srcdimensions,
                            dstbounds = menu_bounds
                          )
                        button_attrs = \
                            {
                                "name" : button[0],
                                "x0" : str(int(bounds[0])),
                                "y0" : str(int(bounds[1]) & ~1),
                                "x1" : str(int(bounds[0] + bounds[2])),
                                "y1" : str(int(bounds[1] + bounds[3]) & ~1),
                            }
                        for neighbour in ("up", "down", "left", "right") :
                            if neighbour in button_spec :
                                button_attrs[neighbour] = button_spec[neighbour] # fixme check it exists?
                            #end if
                        #end for
                        button_tag = XMLElementTree.SubElement \
                          (
                            spu,
                            ("button", "action")[button_spec.get("auto", False)],
                            button_attrs
                          )
                    #end for
                    out_file = open(menu_filenames[letterboxed], "wb")
                    XMLElementTree.ElementTree(subpictures).write(out_file, "utf-8")
                    out_file.flush()
                    out_file.close()
                #end if generate_menu[letterboxed]
                if letterboxed or not loaded_image.widescreen :
                    break
                letterboxed = True
            #end while
        #end if
    else :
        error_alert("Nothing to save.")
    #end if
#end select_save_menu

def about_me(the_window) :
    # displays a dialog showing information about the program.
    about = Gtk.AboutDialog()
    about.set_name("DVD Menu Animator")
    about.set_version("0.04")
    about.set_comments("A utility to ease the construction of DVD-Video menus")
    about.set_copyright("© 2010-2017 Lawrence D'Oliveiro")
    # about.set_license("GPLv3+")
    # about.set_authors(("Lawrence D'Oliveiro",))
    about.run()
    about.destroy()
#end about_me

#+
# Mainline
#-

def setup_main_window() :
    """creates all the window widgets and attaches all associated event handlers."""
    global main_window
    main_window.window = Gtk.Window()
    main_window.window.connect("destroy", destroy_window)
    common_box_margin = 8
    main_plus_menu_box = Gtk.VBox(False, 0)
    main_menu_bar = box_pack(Gtk.MenuBar(), main_plus_menu_box)
    main_box = box_pack(Gtk.VBox(False, common_box_margin), main_plus_menu_box)
    main_box.set_border_width(common_box_margin)
    menu_accel_group = Gtk.AccelGroup()
    main_window.window.add_accel_group(menu_accel_group)
    file_menu = new_menu(main_menu_bar, "File")
    new_menu_item(file_menu, "Load Menu Image...", menu_accel_group, "O", select_load_menu_image)
    new_menu_item(file_menu, "Load Background Image...", menu_accel_group, "B", select_load_background_image)
    new_menu_item(file_menu, "Load Colours...", menu_accel_group, "L", select_load_colors)
    new_menu_item(file_menu, "Reload Saved Colours...", menu_accel_group, "R", select_load_saved_colors)
    new_menu_separator_item(file_menu)
    new_menu_item(file_menu, "Save Menu...", menu_accel_group, "S", select_save_menu)
    new_menu_separator_item(file_menu)
    new_menu_item(file_menu, "Quit", menu_accel_group, "Q", Gtk.main_quit)
    help_menu = new_menu(main_menu_bar, "Help")
    new_menu_item(help_menu, "About DVD Menu Animator...", None, None, about_me)
    middle_box = box_pack(Gtk.HBox(False, common_box_margin), main_box)
    middle_box.set_border_width(common_box_margin)
    main_window.image_click = box_pack(Gtk.EventBox(), middle_box)
    main_window.image_display = Gtk.Image()
    main_window.image_click.add(main_window.image_display)
    main_window.image_click.set_visible_window(False)
    main_window.image_click.set_above_child(True)
    main_window.image_click.set_can_focus(True)
      # thanks to <http://wiki.sugarlabs.org/go/Features/GTK3/Porting/Implode>
    for \
        signal \
    in \
        (
            "button-press-event",
            "button-release-event",
            "focus-in-event",
            "focus-out-event",
            "key-press-event",
            "motion-notify-event",
        ) \
    :
        main_window.image_click.connect(signal, image_click_event)
    #end for
    lists_col_box = box_pack(Gtk.VBox(False, common_box_margin), middle_box)
    list_1_box = box_pack(Gtk.HBox(False, common_box_margin), lists_col_box)
    radio_box = box_pack(Gtk.VBox(False, common_box_margin), list_1_box)
    list_2_box = box_pack(Gtk.HBox(False, common_box_margin), lists_col_box)
    main_window.color_button_group = None
    main_window.loading = True
    loaded_image.color_showing = 0
    box_pack(Gtk.Label("Using Colours:"), radio_box)
    for index, label in enumerate(("Original", "Normal", "Highlighted", "Selected", "Live")) :
        button = box_pack(Gtk.RadioButton(group = main_window.color_button_group, label = label), radio_box)
        button.dvd_menu_index = index
        button.set_active(main_window.color_button_group == None)
        if main_window.color_button_group == None :
            main_window.color_button_group = button
        else :
            button.set_sensitive(False) # until an image is loaded
        #end if
        button.connect("toggled", color_display_changed, index)
    #end for
    main_window.layer_list = Gtk.ListStore(GObject.TYPE_STRING, GObject.TYPE_STRING)
      # first col is display name, second is layer ID
    main_window.button_list = Gtk.ListStore(GObject.TYPE_STRING, GObject.TYPE_PYOBJECT)
      # first col is button id/name, second is dictionary containing bounds and other info
    main_window.button_highlight = None
      # button to draw in highlighted/selected colours
    main_window.button_selected = False
    main_window.button_blink_task = None
    main_window.colors_normal_list = Gtk.ListStore(GObject.TYPE_PYOBJECT)
    main_window.colors_highlighted_list = Gtk.ListStore(GObject.TYPE_PYOBJECT)
    main_window.colors_selected_list = Gtk.ListStore(GObject.TYPE_PYOBJECT)
    main_window.loaded_colors_list = Gtk.ListStore(GObject.TYPE_PYOBJECT)
    name_list_bounds = (160, 160)
    color_list_bounds = (120, 120)
    main_window.button_display = define_scrolling_list \
      (
        list_model = main_window.button_list,
        col = 0,
        renderer = None,
        col_attribute = "text",
        heading = "Buttons",
        bounds = name_list_bounds,
        on_selection_changed = None, # fixme perhaps sync list selection to live button selection
        add_to_box = list_1_box
      )
    main_window.layer_display = define_scrolling_list \
      (
        list_model = main_window.layer_list,
        col = 0,
        renderer = None,
        col_attribute = "text",
        heading = "Button Layer",
        bounds = name_list_bounds,
        on_selection_changed = layer_selection_changed,
        add_to_box = list_1_box
      )
    main_window.colors_normal_display = define_scrolling_list \
      (
        list_model = main_window.colors_normal_list,
        col = 0,
        renderer = ColorCellRenderer(),
        col_attribute = None,
          # can't just simply add my own properties without registering them for an object class
        heading = "Normal",
        bounds = color_list_bounds,
        on_selection_changed = None,
        add_to_box = list_2_box
      )
    main_window.colors_highlighted_display = define_scrolling_list \
      (
        list_model = main_window.colors_highlighted_list,
        col = 0,
        renderer = ColorCellRenderer(),
        col_attribute = None,
        heading = "Highlight",
        bounds = color_list_bounds,
        on_selection_changed = None,
        add_to_box = list_2_box
      )
    main_window.colors_selected_display = define_scrolling_list \
      (
        list_model = main_window.colors_selected_list,
        col = 0,
        renderer = ColorCellRenderer(),
        col_attribute = None,
        heading = "Select",
        bounds = color_list_bounds,
        on_selection_changed = None,
        add_to_box = list_2_box
      )
    main_window.loaded_colors_display = define_scrolling_list \
      (
        list_model = main_window.loaded_colors_list,
        col = 0,
        renderer = ColorCellRenderer(),
        col_attribute = None,
        heading = "",
        bounds = (color_list_bounds[0], color_list_bounds[1] * 2),
        on_selection_changed = None,
        add_to_box = middle_box
      )
    for \
        color_list \
    in \
        (
            main_window.colors_normal_display,
            main_window.colors_highlighted_display,
            main_window.colors_selected_display,
        ) \
    :
        color_list.connect("row-activated", edit_color)
        color_list.connect("drag-data-get", drag_get_color)
        color_list.connect("drag-data-received", drag_set_color)
        color_list.drag_dest_set \
          (
            flags = Gtk.DestDefaults.ALL,
            targets = (Gtk.TargetEntry.new("STRING", Gtk.TargetFlags.SAME_APP, 1),),
            actions = Gdk.DragAction.COPY
          )
        color_list.drag_source_set \
          (
            start_button_mask = Gdk.ModifierType.BUTTON1_MASK,
            targets = (Gtk.TargetEntry.new("STRING", Gtk.TargetFlags.SAME_APP, 1),),
            actions = Gdk.DragAction.COPY
          )
    #end for
    main_window.loaded_colors_display.connect("drag-data-get", drag_get_color)
    main_window.loaded_colors_display.drag_source_set \
      (
        start_button_mask = Gdk.ModifierType.BUTTON1_MASK,
        targets = (Gtk.TargetEntry.new("STRING", Gtk.TargetFlags.SAME_APP, 1),),
        actions = Gdk.DragAction.COPY
      )
    main_window.status_msg = box_pack(Gtk.Label(), main_box)
    main_window.window.add(main_plus_menu_box)
    main_window.window.show_all()
#end setup_main_window

def parse_command_line() :
    """parses command-line options for preloading menu image and other files."""
    (opts, args) = getopt.getopt \
      (
        sys.argv[1:],
        "",
        ["background=", "palette=", "saved="]
      )
    if len(args) > 1 :
        raise getopt.GetoptError("expecting no more than one arg, the menu image filename to load")
    #end if
    if len(args) > 0 :
        load_menu_image(args[0])
    #end if
    for keyword, value in opts :
        if keyword == "--background" :
            load_background_image(value)
        elif keyword == "--palette" :
            load_colors(value)
        elif keyword == "--saved" :
            load_saved_colors(value)
        #end if
    #end for
#end parse_command_line

setup_main_window()
loaded_image.contents = None # to begin with
loaded_image.background = None # ditto
parse_command_line()
main_window.window.show()
Gtk.main()
