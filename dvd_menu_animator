#!/usr/bin/python
#+
# This script aims to simplify the job of creating menus for DVD-Video
# discs. It takes as input an SVG graphic created by Inkscape representing the
# menu image and button locations, lets the user choose additional colours for
# displaying menu buttons in their highlighted and selected states, and generates
# files suitable for input to the spumux tool in the dvdauthor package.
#
# Written by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

from __future__ import division
import sys
import os
import subprocess
import re
import array
import xml.parsers.expat
from xml.etree import \
	ElementTree as XMLElementTree
import cairo
import rsvg
import glib
import gobject
import gtk
import getopt

import spuhelper

#+
# Miscellaneous useful stuff
#-

class Failure(Exception) :

	def __init__(self, Msg) :
		self.Msg = Msg
	#end __init__

#end Failure

#+
# Namespaces
#-

class ns :
	"""XML namespaces."""
	svg = "http://www.w3.org/2000/svg"
	sodipodi = "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
	inkscape = "http://www.inkscape.org/namespaces/inkscape"
#end ns

#+
# Useful GUI stuff
#-

def BoxPack(TheWidget, TheBox) :
	"""packes TheWidget at the start of TheBox and also returns it."""
	TheBox.pack_start(TheWidget, False, False, 0)
	return TheWidget
#end BoxPack

def NewMenu(InMenuBar, Label) :
	"""creates a new menu in the specified menu bar with the specified name."""
	BarMenuItem = gtk.MenuItem(label = Label)
	TheMenu = gtk.Menu()
	BarMenuItem.set_submenu(TheMenu)
	InMenuBar.append(BarMenuItem)
	return TheMenu
#end NewMenu

def NewMenuItem(InMenu, Label, AccelGroup, AccelKey, Action) :
	"""creates a new item in the specified menu with the specified label,
	action to be performed on selection, and optional accelerator key."""
	TheItem = gtk.MenuItem(label = Label)
	TheItem.connect("activate", Action)
	InMenu.append(TheItem)
	if AccelGroup != None :
		TheItem.add_accelerator \
		  (
			accel_signal = "activate",
			accel_group = AccelGroup,
			accel_key = ord(AccelKey),
			accel_mods = gtk.gdk.CONTROL_MASK,
			accel_flags = gtk.ACCEL_VISIBLE
		  )
	#end if
	return TheItem
#end NewMenuItem

def NewMenuSeparatorItem(InMenu) :
	"""creates a new separator item in the specified menu."""
	TheItem = gtk.MenuItem(label = None)
	InMenu.append(TheItem)
#end NewMenuSeparatorItem

def DefineScrollingList \
  (
	ListModel, # the list/tree model to use
	Col, # which column of ListModel to get cell value from
	Heading, # heading for display
	Bounds, # list bounds
	Renderer, # defaults to text renderer if omitted
	ColAttribute, # name of renderer attribute to set to cell value
	OnSelectionChanged, # the action to connect to the "changed" signal
	AddToBox, # the HBox or VBox in which to pack the list
  ) :
	"""creates a single-column scrolling list of items taken from the specified
	column of ListModel, with the specified heading."""
	ListDisplay = gtk.TreeView(ListModel)
	Column = gtk.TreeViewColumn(Heading)
	Column.set_alignment(0.5)
	ListDisplay.append_column(Column)
	if Renderer == None :
		Renderer = gtk.CellRendererText()
	#end if
	Column.pack_start(Renderer, True)
	if ColAttribute == None and hasattr(Renderer, "on_celldata") :
		Column.set_cell_data_func(Renderer, Renderer.on_celldata, None)
		  # on_celldata should be a static method
	else :
		Column.add_attribute(Renderer, ColAttribute, Col)
	#end if
	ListScrolledDisplay = gtk.ScrolledWindow()
	ListScrolledDisplay.set_policy \
	  (
		hscrollbar_policy = gtk.POLICY_NEVER,
		vscrollbar_policy = gtk.POLICY_ALWAYS
	  )
	ListScrolledDisplay.add(ListDisplay)
	ListScrolledDisplay.set_size_request(*Bounds)
	BoxPack(ListScrolledDisplay, AddToBox)
	ListSelection = ListDisplay.get_selection()
	ListSelection.set_mode(gtk.SELECTION_SINGLE)
	if OnSelectionChanged != None :
		ListSelection.connect("changed", OnSelectionChanged)
	#end if
	return ListDisplay
#end DefineScrollingList

def GetSingleListSelection(ListDisplay, Col) :
	"""returns the value from the specified column of the currently-selected item
	in a list, or None if none."""
	SelectedItems = ListDisplay.get_selection().get_selected_rows()
	if len(SelectedItems[1]) != 0 :
		Selection = tuple(SelectedItems[0][SelectedItems[1][0]])[Col]
	else :
		Selection = None
	#end if
	return Selection
#end GetSingleListSelection

class ColorCellRenderer(gtk.GenericCellRenderer) :

	# def __init__(self) :
	#     mustn't be present, or it doesn't get initialized properly
	#end __init__

	def on_get_size(self, DrawWhere, CellRect) :
		return (0, 0, 160, 20)
	#end on_get_size

	@staticmethod
	def on_celldata(Column, Cell, Model, Iter, UserData) :
		Cell.color = tuple(i * 257 for i in Model.get_value(Iter, 0))
	#end on_celldata

	def on_render(self, DrawWhere, DrawOwner, BackgroundRect, CellRect, ExposeRect, Flags) :
		Draw = gtk.gdk.GC(DrawWhere)
		ColorMap = Draw.get_colormap()
		Draw.set_function(gtk.gdk.COPY)
		Fade = 0xffff - self.color[3]
		Draw.set_foreground(ColorMap.alloc_color(gtk.gdk.Color(self.color[0] + Fade, self.color[1] + Fade, self.color[2] + Fade)))
		DrawWhere.draw_rectangle(Draw, True, CellRect.x, CellRect.y, CellRect.width, CellRect.height)
		if Flags == gtk.CELL_RENDERER_SELECTED :
			Draw.set_function(gtk.gdk.INVERT)
			Draw.set_line_attributes \
			  (
				line_width = 2,
				line_style = gtk.gdk.LINE_SOLID,
				cap_style = gtk.gdk.CAP_BUTT,
				join_style = gtk.gdk.JOIN_MITER
			  )
			DrawWhere.draw_rectangle(Draw, False, CellRect.x, CellRect.y, CellRect.width, CellRect.height)
		#end if
	#end on_render

	def on_activate(self, TheEvent, EventTarget, LocationPath, BackgroundRect, CellRect, Flags) :
		pass
	#end on_activate

#end ColorCellRenderer

def ErrorAlert(Msg) :
	"""displays a simple modal alert error message box."""
	TheDialog = gtk.MessageDialog \
	  (
		flags = gtk.DIALOG_MODAL,
		buttons = gtk.BUTTONS_OK,
		type = gtk.MESSAGE_ERROR,
		message_format = Msg
	  )
	Response = TheDialog.run()
	TheDialog.destroy()
#end ErrorAlert

#+
# Global Data
#-

class MainWindow :
	# Window -- gtk.Window object for main window
	pass
#end MainWindow

class LoadedImage :
	# Contents -- parsed XML contents of image file
	# FileName -- pathname of image file
	pass
#end LoadedImage

#+
# Image management
#-

def ImageAsSVG() :
	"""returns the loaded image in SVG textual form."""
	return XMLElementTree.tostring(LoadedImage.Contents.getroot(), "utf-8")
#end ImageAsSVG

def RenderImagePix() :
	"""allocates an array object and fills it with a pixel representation of the
	loaded image."""
	ImageDrawSize = ((720, 540), (960, 540))[LoadedImage.Widescreen]
	if hasattr(cairo, "format_stride_for_width") :
		RowStride = cairo.format_stride_for_width(cairo.FORMAT_ARGB32, ImageDrawSize[0])
	else :
		RowStride = ImageDrawSize[0] * 4
	#end if
	Pixels = array.array \
	  (
		"B",
			(255, 255, 255, 255)
		*
			(RowStride // 4 * ImageDrawSize[1])
	  )
	OffscreenPix = cairo.ImageSurface.create_for_data \
	  (
		Pixels, # data
		cairo.FORMAT_ARGB32, # format
		ImageDrawSize[0], # width
		ImageDrawSize[1], # height
		RowStride # stride
	  )
	Offscreen = cairo.Context(OffscreenPix)
	Offscreen.identity_matrix()
	Offscreen.reset_clip()
	Offscreen.rectangle(*((0, 0) + ImageDrawSize))
	Offscreen.set_source_rgba(1, 1, 1, 1)
	Offscreen.fill()
	ScaleFactor = min \
	  (
		ImageDrawSize[0] / LoadedImage.SrcDimensions[0],
		ImageDrawSize[1] / LoadedImage.SrcDimensions[1],
	  ) # make sure it's all visible
	Offscreen.scale(ScaleFactor, ScaleFactor)
	svg = rsvg.Handle(data = ImageAsSVG())
	svg.render_cairo(Offscreen)
	OffscreenPix.flush()
	return (Pixels, ImageDrawSize, RowStride)
#end RenderImagePix

def AnalyzeImage() :
	"""hides the button layer and determines what colours are present in the rest
	of the image."""
	SelectedLayerID = GetSingleListSelection(MainWindow.LayerDisplay, 1)
	for Layer in LoadedImage.Contents.findall("{%s}g" % ns.svg) :
		LayerID = Layer.get("id")
		if LayerID in LoadedImage.Layers :
			Layer.set \
			  (
				"style",
					"display:"
				+
					("none", "inline")
						[LayerID != SelectedLayerID and LoadedImage.Layers[LayerID]["visible"]]
						  # set button layer to invisible, restore visibility of rest to
						  # original state
			  )
		#end if
	#end for
	IndexedImage, Colors = spuhelper.index_image(RenderImagePix()[0])
	MainWindow.ColorsNormalList.clear()
	for Color in Colors :
		MainWindow.ColorsNormalList.append((Color[0],))
	#end for
	# more TBD using LoadedImage.ColorShowing
	if IndexedImage == None :
		Msg = "<span foreground=\"#FF0000\">%d colours is too many, mustn't exceed 4</span>" % len(Colors)
	else :
		Msg = ""
	#end if
	MainWindow.StatusMsg.set_markup(Msg)
#end AnalyzeImage

def DisplayImage() :
	"""(re)displays the currently-loaded SVG image."""
	if LoadedImage.Contents != None :
		Pixels, ImageDrawSize, RowStride = RenderImagePix()
		spuhelper.cairo_to_gtk(Pixels)
		Offscreen = gtk.gdk.pixbuf_new_from_data \
		  (
			data = Pixels.tostring(),
			colorspace = gtk.gdk.COLORSPACE_RGB, # hope this matches the Cairo layout
			has_alpha = True,
			bits_per_sample = 8,
			width = ImageDrawSize[0],
			height = ImageDrawSize[1],
			rowstride = RowStride
		  )
		MainWindow.ImageDisplay.set_from_pixbuf(Offscreen)
	#end if
#end DisplayImage

def LoadImage(FileName) :
	"""loads a new SVG image file and also collects various useful information about it."""
	try :
		try :
			NewContents = XMLElementTree.parse(FileName)
		except xml.parsers.expat.ExpatError :
			raise Failure("Not a valid SVG file.")
		#end try
		NewLayers = {}
		NewLayerList = []
		SVGTag = NewContents.getroot()
		NewSrcDimensions = (float(SVGTag.get("width")), float(SVGTag.get("height")))
		AspectRatio = NewSrcDimensions[0] / NewSrcDimensions[1]
		AspectTolerance = 0.05 # give user some room to be sloppy
		if abs(AspectRatio / 4 * 3 - 1) <= AspectTolerance :
			Widescreen = False
		elif abs(AspectRatio / 16 * 9 - 1) <= AspectTolerance :
			Widescreen = True
		else :
			raise Failure("Image dimensions cannot be approximated as either 4:3 or 16:9")
		#end if
		for Layer in NewContents.findall("{%s}g" % ns.svg) :
			if Layer.get("{%s}groupmode" % ns.inkscape) == "layer" :
				LayerID = Layer.get("id")
				sys.stderr.write("found layer ID = %s\n" % repr(LayerID)) # debug
				NewLayers[LayerID] = \
					{
						"visible" : Layer.get("style") != "display:none",
						  # save initial visibility state
						  # Assumption: Inkscape only sets style attribute to "display:inline"
						  # for visible layers and "display:none" for invisible ones
					}
				NewLayerList.append \
				  (
					(Layer.get("{%s}label" % ns.inkscape), LayerID)
				  )
			#end if
		#end for
		if len(NewLayerList) == 0 :
			raise Failure("No layers found in document. Are you sure it was created by Inkscape?")
		#end if
		if len(NewLayerList) == 1 :
			raise Failure("Need at least 2 layers, one for buttons and the rest for the image.")
		#end if
		# passed all validation checks
		MainWindow.Loading = True # suspend triggering of ColorDisplayChanged
		LoadedImage.FileName = FileName
		LoadedImage.Contents = NewContents
		LoadedImage.SrcDimensions = NewSrcDimensions
		LoadedImage.Widescreen = Widescreen
		# MainWindow.ImageDisplay.set_size_request(*(((720, 540), (960, 540))[Widescreen]))
		  # how can I keep it user-resizable?
		MainWindow.LayerList.clear()
		for Layer in NewLayerList :
			MainWindow.LayerList.append(Layer)
		#end for
		LoadedImage.Layers = NewLayers
		LoadedImage.ColorShowing = 0
		for Index, Button in enumerate(MainWindow.ColorButtonGroup.get_group()) :
			Button.set_active(Button == MainWindow.ColorButtonGroup)
			Button.set_flags(gtk.SENSITIVE)
		#end for
		MainWindow.Loading = False
		AnalyzeImage()
		# MainWindow.ImageDisplay.queue_draw() # why doesn't this work?
		DisplayImage()
	except Failure, Reason :
		ErrorAlert(Reason.Msg)
	#end try
#end LoadImage

def FindButtons() :
	"""finds all button definitions in the selected button layer."""
	TheLayer = None # initial assumption
	SelectedLayerID = GetSingleListSelection(MainWindow.LayerDisplay, 1)
	if SelectedLayerID != None :
		for Layer in LoadedImage.Contents.findall("{%s}g" % ns.svg) :
			if Layer.get("id") == SelectedLayerID :
				TheLayer = Layer
				break
			#end if
		#end for
	#end if
	MainWindow.ButtonList.clear()
	if TheLayer != None :
		for Button in TheLayer.findall("{%s}rect" % ns.svg) :
			ButtonName = Button.get("id")
			ButtonBounds = \
				(
					float(Button.get("x")),
					float(Button.get("y")),
					float(Button.get("width")),
					float(Button.get("height")),
				)
			MainWindow.ButtonList.append((ButtonName, ButtonBounds))
		#end for
	#end if
#end FindButtons()

#+
# GUI callbacks
#-

def DestroyWindow(TheWindow) :
	# called when main window's close box is clicked.
	gtk.main_quit()
#end DestroyWindow

def SelectLoadImage(TheWindow) :
	# lets the user choose an SVG file to load.
	TheDialog = gtk.FileChooserDialog \
	  (
		title = "Choose SVG Image for Menu",
		action = gtk.FILE_CHOOSER_ACTION_OPEN,
		buttons = ("OK", gtk.RESPONSE_OK, "Cancel", gtk.RESPONSE_CANCEL)
	  )
	SVGFilter = gtk.FileFilter()
	SVGFilter.set_name("SVG Files")
	SVGFilter.add_pattern("*.svg")
	TheDialog.add_filter(SVGFilter)
	Response = TheDialog.run()
	if Response == gtk.RESPONSE_OK :
		ImageFileName = TheDialog.get_filename()
	else :
		ImageFileName = None
	#end if
	TheDialog.destroy()
	if ImageFileName != None :
		LoadImage(ImageFileName)
	#end if
#end SelectLoadImage

def LayerSelectionChanged(TheSelection) :
	# called on a change to the selection of the button layer.
	FindButtons()
	AnalyzeImage()
	# MainWindow.ImageDisplay.queue_draw() # why doesn't this work?
	DisplayImage()
#end LayerSelectionChanged

def ColorDisplayChanged(TheButton, Index) :
	sys.stderr.write("button %d active %d\n" % (Index, TheButton.get_active())) # debug
	if not MainWindow.Loading and TheButton.get_active() :
		LoadedImage.ColorShowing = Index
		AnalyzeImage()
		DisplayImage()
	#end if
#end ColorDisplayChanged

#+
# Mainline
#-

def SetupMainWindow() :
	"""creates all the window widgets and attaches all associated event handlers."""
	global MainWindow
	MainWindow.Window = gtk.Window()
	MainWindow.Window.connect("destroy", DestroyWindow)
	CommonBoxMargin = 8
	MainBox = gtk.VBox(False, CommonBoxMargin)
	MainMenuBar = BoxPack(gtk.MenuBar(), MainBox)
	MenuAccelGroup = gtk.AccelGroup()
	MainWindow.Window.add_accel_group(MenuAccelGroup)
	FileMenu = NewMenu(MainMenuBar, "File")
	# FileMenu.set_accel_path("<main>/File") # doesn't seem to work
	NewMenuItem(FileMenu, "Open...", MenuAccelGroup, "O", SelectLoadImage)
	NewMenuSeparatorItem(FileMenu)
	NewMenuItem(FileMenu, "Quit", MenuAccelGroup, "Q", gtk.main_quit)
	MiddleBox = BoxPack(gtk.HBox(False, CommonBoxMargin), MainBox)
	MainWindow.ImageDisplay = BoxPack(gtk.Image(), MiddleBox)
	ListsColBox = BoxPack(gtk.VBox(False, CommonBoxMargin), MiddleBox)
	List1Box = BoxPack(gtk.HBox(False, CommonBoxMargin), ListsColBox)
	RadioBox = BoxPack(gtk.VBox(False, CommonBoxMargin), List1Box)
	List2Box = BoxPack(gtk.HBox(False, CommonBoxMargin), ListsColBox)
	MainWindow.ColorButtonGroup = None
	MainWindow.Loading = True
	LoadedImage.ColorShowing = 0
	BoxPack(gtk.Label("Using Colours:"), RadioBox)
	for Index, Label in enumerate(("Original", "Normal", "Highlighted", "Selected")) :
		Button = BoxPack(gtk.RadioButton(MainWindow.ColorButtonGroup, Label), RadioBox)
		Button.set_active(MainWindow.ColorButtonGroup == None)
		if MainWindow.ColorButtonGroup == None :
			MainWindow.ColorButtonGroup = Button
		else :
			Button.unset_flags(gtk.SENSITIVE) # until an image is loaded
		#end if
		Button.connect("toggled", ColorDisplayChanged, Index)
	#end for
	MainWindow.LayerList = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_STRING)
	  # first col is display name, second is layer ID
	MainWindow.ButtonList = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_PYOBJECT)
	  # first col is button id/name, second is bounds tuple
	MainWindow.ColorsNormalList = gtk.ListStore(gobject.TYPE_PYOBJECT)
	MainWindow.ColorsHighlightedList = gtk.ListStore(gobject.TYPE_PYOBJECT)
	MainWindow.ColorsSelectedList = gtk.ListStore(gobject.TYPE_PYOBJECT)
	CommonListBounds = (160, 160)
	MainWindow.LayerDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.LayerList,
		Col = 0,
		Renderer = None,
		ColAttribute = "text",
		Heading = "Button Layer",
		Bounds = CommonListBounds,
		OnSelectionChanged = LayerSelectionChanged,
		AddToBox = List1Box
	  )
	MainWindow.ButtonDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ButtonList,
		Col = 0,
		Renderer = None,
		ColAttribute = "text",
		Heading = "Buttons",
		Bounds = CommonListBounds,
		OnSelectionChanged = None, # ButtonSelectionChanged TBD
		AddToBox = List1Box
	  )
	MainWindow.ColorsNormalDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ColorsNormalList,
		Col = 0,
		Renderer = ColorCellRenderer(),
		ColAttribute = None, # can't just simply add my own properties without registering them for an object class
		Heading = "Normal",
		Bounds = CommonListBounds,
		OnSelectionChanged = None,
		AddToBox = List2Box
	  )
	MainWindow.ColorsHighlightedDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ColorsHighlightedList,
		Col = 0,
		Renderer = ColorCellRenderer(),
		ColAttribute = None,
		Heading = "Highlight",
		Bounds = CommonListBounds,
		OnSelectionChanged = None,
		AddToBox = List2Box
	  )
	MainWindow.ColorsSelectedDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ColorsSelectedList,
		Col = 0,
		Renderer = ColorCellRenderer(),
		ColAttribute = None,
		Heading = "Select",
		Bounds = CommonListBounds,
		OnSelectionChanged = None,
		AddToBox = List2Box
	  )
	MainWindow.StatusMsg = BoxPack(gtk.Label(), MainBox)
	MainWindow.Window.add(MainBox)
	MainWindow.Window.show_all()
#end SetupMainWindow

SetupMainWindow()
LoadedImage.Contents = None # to begin with
MainWindow.Window.show()
gtk.main()
