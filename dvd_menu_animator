#!/usr/bin/python
#+
# This script aims to simplify the job of creating menus for DVD-Video
# discs. It takes as input an SVG graphic created by Inkscape representing the
# menu image and button locations, lets the user choose additional colours for
# displaying menu buttons in their highlighted and selected states, and generates
# files suitable for input to the spumux tool in the dvdauthor package.
#
# Written by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

from __future__ import division
import sys
import os
import subprocess
import re
import array
import xml.parsers.expat
from xml.etree import \
	ElementTree as XMLElementTree
import cairo
import rsvg
import glib
import gobject
import gtk
import getopt

#+
# Miscellaneous useful stuff
#-

class Failure(Exception) :

	def __init__(self, Msg) :
		self.Msg = Msg
	#end __init__

#end Failure

#+
# Namespaces
#-

class ns :
	"""XML namespaces."""
	svg = "http://www.w3.org/2000/svg"
	sodipodi = "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
	inkscape = "http://www.inkscape.org/namespaces/inkscape"
#end ns

#+
# Useful GUI stuff
#-

def BoxPack(TheWidget, TheBox) :
	"""packes TheWidget at the start of TheBox and also returns it."""
	TheBox.pack_start(TheWidget, False, False, 0)
	return TheWidget
#end BoxPack

def NewMenu(InMenuBar, Label) :
	BarMenuItem = gtk.MenuItem(label = Label)
	TheMenu = gtk.Menu()
	BarMenuItem.set_submenu(TheMenu)
	InMenuBar.append(BarMenuItem)
	return TheMenu
#end NewMenu

def NewMenuItem(InMenu, Label, Action) :
	TheItem = gtk.MenuItem(label = Label)
	TheItem.connect("activate", Action)
	InMenu.append(TheItem)
	return TheItem
#end NewMenuItem

def NewMenuSeparatorItem(InMenu) :
	TheItem = gtk.MenuItem(label = None)
	InMenu.append(TheItem)
#end NewMenuSeparatorItem

def DefineScrollingList \
  (
	ListModel, # the list/tree model to use
	Col, # which column of ListModel
	Heading, # heading for display
	Bounds, # list bounds
	OnSelectionChanged, # the action to connect to the "changed" signal
	AddToBox, # the HBox or VBox in which to pack the list
  ) :
	"""creates a single-column scrolling list of text items taken
	from the specified column of ListModel, with the specified heading."""
	ListDisplay = gtk.TreeView(ListModel)
	Column = gtk.TreeViewColumn(Heading)
	Column.set_alignment(0.5)
	ListDisplay.append_column(Column)
	Renderer = gtk.CellRendererText()
	Column.pack_start(Renderer, True)
	Column.add_attribute(Renderer, "text", Col)
	ListScrolledDisplay = gtk.ScrolledWindow()
	ListScrolledDisplay.set_policy \
	  (
		hscrollbar_policy = gtk.POLICY_NEVER,
		vscrollbar_policy = gtk.POLICY_ALWAYS
	  )
	ListScrolledDisplay.add(ListDisplay)
	ListScrolledDisplay.set_size_request(*Bounds)
	BoxPack(ListScrolledDisplay, AddToBox)
	ListSelection = ListDisplay.get_selection()
	ListSelection.set_mode(gtk.SELECTION_SINGLE)
	if OnSelectionChanged != None :
		ListSelection.connect("changed", OnSelectionChanged)
	#end if
	return ListDisplay
#end DefineScrollingList

def GetSingleListSelection(ListDisplay, Col) :
	"""returns the value from the specified column of the currently-selected item
	in a list, or None if none."""
	SelectedItems = ListDisplay.get_selection().get_selected_rows()
	if len(SelectedItems[1]) != 0 :
		Selection = tuple(SelectedItems[0][SelectedItems[1][0]])[Col]
	else :
		Selection = None
	#end if
	return Selection
#end GetSingleListSelection

def ErrorAlert(Msg) :
	"""displays a simple modal alert error message box."""
	TheDialog = gtk.MessageDialog \
	  (
		flags = gtk.DIALOG_MODAL,
		buttons = gtk.BUTTONS_OK,
		type = gtk.MESSAGE_ERROR,
		message_format = Msg
	  )
	Response = TheDialog.run()
	TheDialog.destroy()
#end ErrorAlert

#+
# Global Data
#-

class MainWindow :
	# Window -- gtk.Window object for main window
	pass
#end MainWindow

class LoadedImage :
	# Contents -- parsed XML contents of image file
	# FileName -- pathname of image file
	pass
#end LoadedImage

#+
# Image management
#-

def ImageAsSVG() :
	"""returns the loaded image in SVG textual form."""
	return XMLElementTree.tostring(LoadedImage.Contents.getroot(), "utf-8")
#end ImageAsSVG

def AnalyzeImage() :
	"""hides the button layer and determines what colours are present in the rest
	of the image. Uses the ImageMagick "identify" program."""
	SelectedLayerID = GetSingleListSelection(MainWindow.LayerDisplay, 1)
	sys.stderr.write("selected layer id = %s\n" % repr(SelectedLayerID)) # debug
	for Layer in LoadedImage.Contents.findall("{%s}g" % ns.svg) :
		LayerID = Layer.get("id")
		if LayerID in LoadedImage.Layers :
			Layer.set \
			  (
				"style",
					"display:"
				+
					("none", "inline")
						[LayerID != SelectedLayerID and LoadedImage.Layers[LayerID]["visible"]]
						  # set button layer to invisible, restore visibility of rest to
						  # original state
			  )
		#end if
	#end for
	Child = subprocess.Popen \
	  (
		args = ("identify", "-verbose", "svg:/dev/stdin"),
		stdin = subprocess.PIPE,
		stdout = subprocess.PIPE,
		close_fds = True,
		shell = False
	  )
	ChildResult, Ignore = Child.communicate(ImageAsSVG())
	if Child.returncode != 0 :
		raise Failure("AnalyzeImage: child terminated with status %04x\n" % Child.returncode)
	#end if
	ChildResult = ChildResult[re.search(r"^\s*Histogram:\s*\n", ChildResult, re.MULTILINE | re.IGNORECASE).end():]
	while True :
		ColorMatch = re.match \
		  (
			r"^\s*(\d+)\:\s+\(\s*(\d+)\,\s*(\d+)\,\s*(\d+)\,\s*(\d+)\).+\n",
			ChildResult,
			re.MULTILINE
		  )
		if ColorMatch == None :
			break
		NrPixels, R, G, B, A = tuple(int(ColorMatch.group(i)) for i in range(1, 6))
		sys.stderr.write("Colour: (%d, %d, %d, %d) = %d\n" % (R, G, B, A, NrPixels)) # debug
		ChildResult = ChildResult[ColorMatch.end():]
	#end while
	# more TBD
#end AnalyzeImage

def DisplayImage() :
	"""(re)displays the currently-loaded SVG image."""
	if LoadedImage.Contents != None :
		if False :
			if MainWindow.ImageDraw == None :
				MainWindow.ImageDraw = MainWindow.ImageDisplay.window.cairo_create()
			#end if
			ImageDrawSize = MainWindow.ImageDisplay.window.get_size()
			MainWindow.ImageDraw.identity_matrix()
			MainWindow.ImageDraw.reset_clip()
			MainWindow.ImageDraw.rectangle(*((0, 0) + ImageDrawSize))
			MainWindow.ImageDraw.set_source_rgb(1, 1, 1)
			MainWindow.ImageDraw.fill()
			ScaleFactor = min \
			  (
				ImageDrawSize[0] / LoadedImage.SrcDimensions[0],
				ImageDrawSize[1] / LoadedImage.SrcDimensions[1],
			  ) # make sure it's all visible
			MainWindow.ImageDraw.scale(ScaleFactor, ScaleFactor)
			svg = rsvg.Handle(data = ImageAsSVG())
			svg.render_cairo(MainWindow.ImageDraw) # causes X errors now
		else :
			# fudge to avoid X errors by rendering SVG to offscreen
			ImageDrawSize = ((720, 540), (960, 540))[LoadedImage.Widescreen]
			if hasattr(cairo, "format_stride_for_width") :
				RowStride = cairo.format_stride_for_width(cairo.FORMAT_ARGB32, ImageDrawSize[0])
			else :
				RowStride = ImageDrawSize[0] * 4
			#end if
			Pixels = array.array \
			  (
				"B",
					(1, 1, 1, 1)
				*
					(RowStride // 4 * ImageDrawSize[1])
			  )
			OffscreenPix = cairo.ImageSurface.create_for_data \
			  (
				Pixels, # data
				cairo.FORMAT_ARGB32, # format
				ImageDrawSize[0], # width
				ImageDrawSize[1], # height
				RowStride # stride
			  )
			Offscreen = cairo.Context(OffscreenPix)
			Offscreen.identity_matrix()
			Offscreen.reset_clip()
			Offscreen.rectangle(*((0, 0) + ImageDrawSize))
			Offscreen.set_source_rgba(1, 1, 1, 1)
			Offscreen.fill()
			ScaleFactor = min \
			  (
				ImageDrawSize[0] / LoadedImage.SrcDimensions[0],
				ImageDrawSize[1] / LoadedImage.SrcDimensions[1],
			  ) # make sure it's all visible
			Offscreen.scale(ScaleFactor, ScaleFactor)
			svg = rsvg.Handle(data = ImageAsSVG())
			svg.render_cairo(Offscreen)
			OffscreenPix.flush()
			for Row in range(0, ImageDrawSize[1]) :
				# need to rearrange pixel components between Cairo and GTK formats.
				# Is this endian-dependent?
				RowBase = Row * RowStride
				for Col in range(0, ImageDrawSize[0]) :
					ColBase = RowBase + Col * 4
					Pixels[ColBase + 0], Pixels[ColBase + 1], Pixels[ColBase + 2], Pixels[ColBase + 3] = Pixels[ColBase + 2], Pixels[ColBase + 1], Pixels[ColBase + 0], Pixels[ColBase + 3]
				#end for
			#end for
			Offscreen = gtk.gdk.pixbuf_new_from_data \
			  (
				data = Pixels.tostring(),
				colorspace = gtk.gdk.COLORSPACE_RGB, # hope this matches the Cairo layout
				has_alpha = True,
				bits_per_sample = 8,
				width = ImageDrawSize[0],
				height = ImageDrawSize[1],
				rowstride = RowStride
			  )
			MainWindow.ImageDisplay.set_from_pixbuf(Offscreen)
		#end if
	#end if
#end DisplayImage

def LoadImage(FileName) :
	"""loads a new SVG image file and also collects various useful information about it."""
	try :
		try :
			NewContents = XMLElementTree.parse(FileName)
		except xml.parsers.expat.ExpatError :
			raise Failure("Not a valid SVG file.")
		#end try
		NewLayers = {}
		NewLayerList = []
		SVGTag = NewContents.getroot()
		NewSrcDimensions = (float(SVGTag.get("width")), float(SVGTag.get("height")))
		AspectRatio = NewSrcDimensions[0] / NewSrcDimensions[1]
		AspectTolerance = 0.05 # give user some room to be sloppy
		if abs(AspectRatio / 4 * 3 - 1) <= AspectTolerance :
			Widescreen = False
		elif abs(AspectRatio / 16 * 9 - 1) <= AspectTolerance :
			Widescreen = True
		else :
			raise Failure("Image dimensions cannot be approximated as either 4:3 or 16:9")
		#end if
		sys.stderr.write("image dimensions = %s, widescreen = %s\n" % (repr(NewSrcDimensions), ("F", "T")[Widescreen])) # debug
		for Layer in NewContents.findall("{%s}g" % ns.svg) :
			if Layer.get("{%s}groupmode" % ns.inkscape) == "layer" :
				LayerID = Layer.get("id")
				sys.stderr.write("found layer ID = %s\n" % repr(LayerID)) # debug
				NewLayers[LayerID] = \
					{
						"visible" : Layer.get("style") != "display:none",
						  # save initial visibility state
						  # Assumption: Inkscape only sets style attribute to "display:inline"
						  # for visible layers and "display:none" for invisible ones
					}
				NewLayerList.append \
				  (
					(Layer.get("{%s}label" % ns.inkscape), LayerID)
				  )
			#end if
		#end for
		if len(NewLayerList) == 0 :
			raise Failure("No layers found in document. Are you sure it was created by Inkscape?")
		#end if
		if len(NewLayerList) == 1 :
			raise Failure("Need at least 2 layers, one for buttons and the rest for the image.")
		#end if
		# passed all validation checks
		LoadedImage.FileName = FileName
		LoadedImage.Contents = NewContents
		LoadedImage.SrcDimensions = NewSrcDimensions
		LoadedImage.Widescreen = Widescreen
		# MainWindow.ImageDisplay.set_size_request(*(((720, 540), (960, 540))[Widescreen]))
		  # how can I keep it user-resizable?
		MainWindow.LayerList.clear()
		for Layer in NewLayerList :
			MainWindow.LayerList.append(Layer)
		#end for
		LoadedImage.Layers = NewLayers
		AnalyzeImage()
		# MainWindow.ImageDisplay.queue_draw() # why doesn't this work?
		DisplayImage()
	except Failure, Reason :
		ErrorAlert(Reason.Msg)
	#end try
#end LoadImage

def FindButtons() :
	"""finds all button definitions in the selected button layer."""
	TheLayer = None # initial assumption
	SelectedLayerID = GetSingleListSelection(MainWindow.LayerDisplay, 1)
	if SelectedLayerID != None :
		for Layer in LoadedImage.Contents.findall("{%s}g" % ns.svg) :
			if Layer.get("id") == SelectedLayerID :
				TheLayer = Layer
				break
			#end if
		#end for
	#end if
	MainWindow.ButtonList.clear()
	if TheLayer != None :
		for Button in TheLayer.findall("{%s}rect" % ns.svg) :
			ButtonName = Button.get("id")
			ButtonBounds = \
				(
					float(Button.get("x")),
					float(Button.get("y")),
					float(Button.get("width")),
					float(Button.get("height")),
				)
			MainWindow.ButtonList.append((ButtonName, ButtonBounds))
		#end for
	#end if
#end FindButtons()

#+
# GUI callbacks
#-

def DestroyWindow(TheWindow) :
	# called when main window's close box is clicked.
	gtk.main_quit()
#end DestroyWindow

def SelectLoadImage(TheWindow) :
	# lets the user choose an SVG file to load.
	TheDialog = gtk.FileChooserDialog \
	  (
		title = "Choose SVG Image for Menu",
		action = gtk.FILE_CHOOSER_ACTION_OPEN,
		buttons = ("OK", gtk.RESPONSE_OK, "Cancel", gtk.RESPONSE_CANCEL)
	  )
	SVGFilter = gtk.FileFilter()
	SVGFilter.set_name("SVG Files")
	SVGFilter.add_pattern("*.svg")
	TheDialog.add_filter(SVGFilter)
	Response = TheDialog.run()
	if Response == gtk.RESPONSE_OK :
		ImageFileName = TheDialog.get_filename()
	else :
		ImageFileName = None
	#end if
	TheDialog.destroy()
	if ImageFileName != None :
		LoadImage(ImageFileName)
	#end if
#end SelectLoadImage

def ImageRedisplay(ImageDisplay, TheEvent) :
	sys.stderr.write("expose event received\n") # debug
	DisplayImage() # why doesn't this work?
	return True
#end ImageRedisplay

def LayerSelectionChanged(TheSelection) :
	# called on a change to the selection of the button layer.
	FindButtons()
	AnalyzeImage()
	# MainWindow.ImageDisplay.queue_draw() # why doesn't this work?
	DisplayImage()
#end LayerSelectionChanged

#+
# Mainline
#-

def SetupMainWindow() :
	"""creates all the window widgets and attaches all associated event handlers."""
	global MainWindow
	MainWindow.Window = gtk.Window()
	MainWindow.Window.connect("destroy", DestroyWindow)
	CommonBoxMargin = 8
	MainBox = gtk.VBox(False, CommonBoxMargin)
	MainMenuBar = BoxPack(gtk.MenuBar(), MainBox)
	FileMenu = NewMenu(MainMenuBar, "File")
	# FileMenu.set_accel_path("<main>/File") # doesn't seem to work
	NewMenuItem(FileMenu, "Open...", SelectLoadImage)
	NewMenuSeparatorItem(FileMenu)
	NewMenuItem(FileMenu, "Quit", gtk.main_quit)
	MiddleBox = BoxPack(gtk.HBox(False, CommonBoxMargin), MainBox)
	if False :
		MainWindow.ImageDisplay = BoxPack(gtk.DrawingArea(), MiddleBox)
		MainWindow.ImageDisplay.set_app_paintable(True) # ?
		MainWindow.ImageDisplay.connect("expose-event", ImageRedisplay)
		MainWindow.ImageDisplay.set_size_request(640, 480)
		MainWindow.ImageDraw = None # can't create yet
	else :
		MainWindow.ImageDisplay = BoxPack(gtk.Image(), MiddleBox)
	#end if
	ListsColBox = BoxPack(gtk.VBox(False, CommonBoxMargin), MiddleBox)
	List1Box = BoxPack(gtk.HBox(False, CommonBoxMargin), ListsColBox)
	List2Box = BoxPack(gtk.HBox(False, CommonBoxMargin), ListsColBox)
	MainWindow.LayerList = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_STRING)
	  # first col is display name, second is layer ID
	MainWindow.ButtonList = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_PYOBJECT)
	  # first col is button id/name, second is bounds tuple
	MainWindow.ColorsNormalList = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_PYOBJECT)
	MainWindow.ColorsHighlightedList = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_PYOBJECT)
	MainWindow.ColorsSelectedList = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_PYOBJECT)
	CommonListBounds = (160, 160)
	MainWindow.LayerDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.LayerList,
		Col = 0,
		Heading = "Button Layer",
		Bounds = CommonListBounds,
		OnSelectionChanged = LayerSelectionChanged,
		AddToBox = List1Box
	  )
	MainWindow.ButtonDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ButtonList,
		Col = 0,
		Heading = "Buttons",
		Bounds = CommonListBounds,
		OnSelectionChanged = None, # ButtonSelectionChanged TBD
		AddToBox = List1Box
	  )
	# TBD replace DefineScrollingList below with custom renderer to show actual colours
	MainWindow.ColorsNormalDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ColorsNormalList,
		Col = 0,
		Heading = "Normal",
		Bounds = CommonListBounds,
		OnSelectionChanged = None,
		AddToBox = List2Box
	  )
	MainWindow.ColorsHighlightedDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ColorsHighlightedList,
		Col = 0,
		Heading = "Highlight",
		Bounds = CommonListBounds,
		OnSelectionChanged = None,
		AddToBox = List2Box
	  )
	MainWindow.ColorsSelectedDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ColorsSelectedList,
		Col = 0,
		Heading = "Select",
		Bounds = CommonListBounds,
		OnSelectionChanged = None,
		AddToBox = List2Box
	  )
	MainWindow.Window.add(MainBox)
	MainWindow.Window.show_all()
#end SetupMainWindow

SetupMainWindow()
LoadedImage.Contents = None # to begin with
MainWindow.Window.show()
gtk.main()
