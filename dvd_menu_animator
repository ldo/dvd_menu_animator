#!/usr/bin/python
# -*- coding: utf-8
#+
# This script aims to simplify the job of creating menus for DVD-Video
# discs. It takes as input an SVG graphic created by Inkscape representing the
# menu image and button locations, lets the user choose additional colours for
# displaying menu buttons in their highlighted and selected states, and generates
# files suitable for input to the spumux tool in the dvdauthor package.
#
# Written by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

from __future__ import division
import sys
import os
import subprocess
import re
import array
import xml.parsers.expat
from xml.etree import \
	ElementTree as XMLElementTree
import cairo
import rsvg
import glib
import gobject
import gtk
import getopt

import spuhelper

#+
# Miscellaneous useful stuff
#-

class Failure(Exception) :

	def __init__(self, Msg) :
		self.Msg = Msg
	#end __init__

#end Failure

class ns :
	"""XML namespaces used in SVG files."""
	svg = "http://www.w3.org/2000/svg"
	sodipodi = "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
	inkscape = "http://www.inkscape.org/namespaces/inkscape"
#end ns

class keyval :
	"""are there official symbolic names for these anywhere?"""
	returnkey = 0xff0d
	enterkey = 0xff8d
#end keyval

select_delay = 0.25
  # how long to display a button in the selected state

def RectMatrix(SrcRect, DstRect) :
	"""returns a Cairo matrix that maps the corners of SrcRect to DstRect."""
	Result = cairo.Matrix()
	Result.translate(- SrcRect[0], - SrcRect[1])
	Result.scale(DstRect[2] / SrcRect[2], DstRect[3] / SrcRect[3])
	Result.translate(DstRect[0], DstRect[1])
	return Result
#end RectMatrix

#+
# Useful GUI stuff
#-

def BoxPack(TheWidget, TheBox) :
	"""packes TheWidget at the start of TheBox and also returns it."""
	TheBox.pack_start(TheWidget, False, False, 0)
	return TheWidget
#end BoxPack

def NewMenu(InMenuBar, Label) :
	"""creates a new menu in the specified menu bar with the specified name."""
	BarMenuItem = gtk.MenuItem(label = Label)
	TheMenu = gtk.Menu()
	BarMenuItem.set_submenu(TheMenu)
	InMenuBar.append(BarMenuItem)
	return TheMenu
#end NewMenu

def NewMenuItem(InMenu, Label, AccelGroup, AccelKey, Action) :
	"""creates a new item in the specified menu with the specified label,
	action to be performed on selection, and optional accelerator key."""
	TheItem = gtk.MenuItem(label = Label)
	TheItem.connect("activate", Action)
	InMenu.append(TheItem)
	if AccelGroup != None :
		TheItem.add_accelerator \
		  (
			accel_signal = "activate",
			accel_group = AccelGroup,
			accel_key = ord(AccelKey),
			accel_mods = gtk.gdk.CONTROL_MASK,
			accel_flags = gtk.ACCEL_VISIBLE
		  )
	#end if
	return TheItem
#end NewMenuItem

def NewMenuSeparatorItem(InMenu) :
	"""creates a new separator item in the specified menu."""
	TheItem = gtk.MenuItem(label = None)
	InMenu.append(TheItem)
#end NewMenuSeparatorItem

def DefineScrollingList \
  (
	ListModel, # the list/tree model to use
	Col, # which column of ListModel to get cell value from
	Heading, # heading for display
	Bounds, # list bounds
	Renderer, # defaults to text renderer if omitted
	ColAttribute, # name of renderer attribute to set to cell value
	OnSelectionChanged, # the action to connect to the "changed" signal
	AddToBox, # the HBox or VBox in which to pack the list
  ) :
	"""creates a single-column scrolling list of items taken from the specified
	column of ListModel, with the specified heading."""
	ListDisplay = gtk.TreeView(ListModel)
	Column = gtk.TreeViewColumn(Heading)
	Column.set_alignment(0)
	ListDisplay.append_column(Column)
	if Renderer == None :
		Renderer = gtk.CellRendererText()
	#end if
	Column.pack_start(Renderer, True)
	if ColAttribute == None and hasattr(Renderer, "on_celldata") :
		Column.set_cell_data_func(Renderer, Renderer.on_celldata, None)
		  # on_celldata should be a static method
	else :
		Column.add_attribute(Renderer, ColAttribute, Col)
	#end if
	ListScrolledDisplay = gtk.ScrolledWindow()
	ListScrolledDisplay.set_policy \
	  (
		hscrollbar_policy = gtk.POLICY_NEVER,
		vscrollbar_policy = gtk.POLICY_ALWAYS
	  )
	ListScrolledDisplay.add(ListDisplay)
	ListScrolledDisplay.set_size_request(*Bounds)
	BoxPack(ListScrolledDisplay, AddToBox)
	ListSelection = ListDisplay.get_selection()
	ListSelection.set_mode(gtk.SELECTION_SINGLE)
	if OnSelectionChanged != None :
		ListSelection.connect("changed", OnSelectionChanged)
	#end if
	return ListDisplay
#end DefineScrollingList

def GetSingleListSelection(ListDisplay, Col) :
	"""returns the value from the specified column of the currently-selected item
	in a list, or None if none."""
	SelectedItems = ListDisplay.get_selection().get_selected_rows()
	if len(SelectedItems[1]) != 0 :
		Selection = tuple(SelectedItems[0][SelectedItems[1][0]])[Col]
	else :
		Selection = None
	#end if
	return Selection
#end GetSingleListSelection

class ColorCellRenderer(gtk.GenericCellRenderer) :

	# def __init__(self) :
	#     mustn't be present, or it doesn't get initialized properly
	#end __init__

	def on_get_size(self, DrawWhere, CellRect) :
		return (0, 0, 160, 20)
	#end on_get_size

	@staticmethod
	def on_celldata(Column, Cell, Model, Iter, UserData) :
		Cell.color = tuple(i / 255 for i in Model.get_value(Iter, 0))
	#end on_celldata

	def on_render(self, DrawWhere, DrawOwner, BackgroundRect, CellRect, ExposeRect, Flags) :
		Draw = gtk.gdk.GC(DrawWhere)
		ColorMap = Draw.get_colormap()
		Draw.set_function(gtk.gdk.COPY)
		Opacity = self.color[3]
		Draw.set_foreground \
		  (
			ColorMap.alloc_color
			  (
				gtk.gdk.Color
				  (
					*tuple
					  (
						int(round(((c - 0.5) * Opacity + 0.5) * 65535))
						for c in self.color[:3]
					  )
				  )
			  )
		  )
		DrawWhere.draw_rectangle(Draw, True, CellRect.x, CellRect.y, CellRect.width, CellRect.height)
		if Flags == gtk.CELL_RENDERER_SELECTED :
			Draw.set_function(gtk.gdk.INVERT)
			Draw.set_line_attributes \
			  (
				line_width = 2,
				line_style = gtk.gdk.LINE_SOLID,
				cap_style = gtk.gdk.CAP_BUTT,
				join_style = gtk.gdk.JOIN_MITER
			  )
			DrawWhere.draw_rectangle(Draw, False, CellRect.x, CellRect.y, CellRect.width, CellRect.height)
		#end if
	#end on_render

	def on_activate(self, TheEvent, EventTarget, LocationPath, BackgroundRect, CellRect, Flags) :
		pass
	#end on_activate

#end ColorCellRenderer

def ErrorAlert(Msg) :
	"""displays a simple modal alert error message box."""
	TheDialog = gtk.MessageDialog \
	  (
		flags = gtk.DIALOG_MODAL,
		buttons = gtk.BUTTONS_OK,
		type = gtk.MESSAGE_ERROR,
		message_format = Msg
	  )
	Response = TheDialog.run()
	TheDialog.destroy()
#end ErrorAlert

def ForgetButtonBlink() :
	if MainWindow.ButtonBlinkTask != None :
		glib.source_remove(MainWindow.ButtonBlinkTask)
		MainWindow.ButtonBlinkTask = None
	#end if
	MainWindow.ButtonSelected = False
#end ForgetButtonBlink

def BlinkHighlightedButton() :
	ForgetButtonBlink()
	MainWindow.ButtonBlinkTask = glib.timeout_add \
	  (
		int(round(select_delay * 1000)),
		ButtonSelectionDone
	  )
	MainWindow.ButtonSelected = True
	DisplayImage()
#end BlinkHighlightedButton

#+
# Global Data
#-

class MainWindow :
	# Window -- gtk.Window object for main window
	pass
#end MainWindow

class LoadedImage :
	# Contents -- parsed XML contents of image file
	# FileName -- pathname of image file
	pass
#end LoadedImage

#+
# Image management
#-

def ImageAsSVG() :
	"""returns the loaded image in SVG textual form."""
	return XMLElementTree.tostring(LoadedImage.Contents.getroot(), "utf-8")
#end ImageAsSVG

def RenderImagePix() :
	"""allocates an array object and fills it with a pixel representation of the
	loaded image."""
	Pixels = array.array \
	  (
		"B",
			(255, 255, 255, 255)
		*
			(LoadedImage.RowStride // 4 * LoadedImage.ImageDrawSize[1])
	  )
	OffscreenPix = cairo.ImageSurface.create_for_data \
	  (
		Pixels, # data
		cairo.FORMAT_ARGB32, # format
		LoadedImage.ImageDrawSize[0], # width
		LoadedImage.ImageDrawSize[1], # height
		LoadedImage.RowStride # stride
	  )
	Offscreen = cairo.Context(OffscreenPix)
	Offscreen.identity_matrix()
	Offscreen.set_source_rgba(1, 1, 1, 1)
	Offscreen.paint()
	ScaleFactor = min \
	  (
		LoadedImage.ImageDrawSize[0] / LoadedImage.SrcDimensions[0],
		LoadedImage.ImageDrawSize[1] / LoadedImage.SrcDimensions[1],
	  ) # make sure it's all visible
	Offscreen.scale(ScaleFactor, ScaleFactor)
	svg = rsvg.Handle(data = ImageAsSVG())
	svg.render_cairo(Offscreen)
	OffscreenPix.flush()
	return Pixels
#end RenderImagePix

def AnalyzeImage() :
	"""hides the button layer and determines what colours are present in the rest
	of the image."""
	LoadedImage.ImageDrawSize = ((480, 360), (640, 360))[LoadedImage.Widescreen]
	if hasattr(cairo, "format_stride_for_width") :
		LoadedImage.RowStride = cairo.format_stride_for_width \
		  (
			cairo.FORMAT_ARGB32,
			LoadedImage.ImageDrawSize[0]
		  )
	else :
		LoadedImage.RowStride = LoadedImage.ImageDrawSize[0] * 4
	#end if
	SelectedLayerID = GetSingleListSelection(MainWindow.LayerDisplay, 1)
	for Layer in LoadedImage.Contents.findall("{%s}g" % ns.svg) :
		LayerID = Layer.get("id")
		if LayerID in LoadedImage.Layers :
			Layer.set \
			  (
				"style",
					"display:"
				+
					("none", "inline")
						[LayerID != SelectedLayerID and LoadedImage.Layers[LayerID]["visible"]]
						  # set button layer to invisible, restore visibility of rest to
						  # original state
			  )
		#end if
	#end for
	LoadedImage.IndexedImage, LoadedImage.Colors = spuhelper.index_image(RenderImagePix())
	LoadedImage.ColorShowing = 0
	if LoadedImage.IndexedImage == None :
		Msg = \
			(
				"<span foreground=\"#FF0000\">%d colours is too many, mustn't exceed 4</span>"
			%
				len(LoadedImage.Colors)
			)
		UseColors = ()
	else :
		Msg = ""
		MainWindow.Loading = True # suspend triggering of ColorDisplayChanged
		for Button in MainWindow.ColorButtonGroup.get_group() :
			Index = Button.get_data("index")
			Button.set_active(Index == 0)
			Button.set_flags(gtk.SENSITIVE)
		#end for
		MainWindow.Loading = False
	#end if
	UseColors = LoadedImage.Colors
	for \
		ColorList \
	in \
		(
			MainWindow.ColorsNormalList,
			MainWindow.ColorsHighlightedList,
			MainWindow.ColorsSelectedList,
		) \
	:
		ColorList.clear()
		for Color in UseColors :
			ColorList.append((Color[0],))
		#end for
		UseColors = UseColors[:4] # no more than 4 for highlighted & selected lists
	#end for
	MainWindow.StatusMsg.set_markup(Msg)
#end AnalyzeImage

def DisplayImage() :
	"""(re)displays the currently-loaded SVG image."""
	if LoadedImage.Contents != None :
		HighlightPixels = None # to begin with
		if LoadedImage.ColorShowing == 0 :
			ImagePixels = RenderImagePix()
		else :
			ColorList = \
				(
					MainWindow.ColorsNormalList,
					MainWindow.ColorsHighlightedList,
					MainWindow.ColorsSelectedList,
					MainWindow.ColorsNormalList
				)[LoadedImage.ColorShowing - 1]
			Colors = tuple(Color[0] for Color in ColorList)
			ImagePixels = spuhelper.expand_image(LoadedImage.IndexedImage, Colors)
			if MainWindow.ButtonHighlightRect != None and LoadedImage.ColorShowing == 4 :
				HighlightPixels = spuhelper.expand_image \
				  (
					LoadedImage.IndexedImage,
					tuple
					  (
						Color[0]
						for Color in
							(
								MainWindow.ColorsHighlightedList,
								MainWindow.ColorsSelectedList
							)[MainWindow.ButtonSelected]
					  )
				  )
			#end if
		#end if
		Light, Dark = 0xFFD6D6D6, 0xFFACACAC
		  # same colours that gtk.ColorSelection uses for background of opacity display
		PatternArray = array.array \
		  (
			"I",
				16 * (16 * (Light,) + 16 * (Dark,))
			+
				16 * (16 * (Dark,) + 16 * (Light,))
		  )
		CheckPattern = cairo.SurfacePattern \
		  (
			cairo.ImageSurface.create_for_data
			  (
				PatternArray, # data
				cairo.FORMAT_ARGB32, # format
				32, # width
				32, # height
				32 * 4 # stride
			  )
		  ) # to show through less-than-fully-opaque pixels
		CheckPattern.set_extend(cairo.EXTEND_REPEAT)
		DisplayPixels = array.array \
		  (
			"B", # not "I" because then tostring puts the bytes in the wrong order
			(255, 255, 255, 255) * LoadedImage.ImageDrawSize[1] * (LoadedImage.RowStride // 4)
		  )
		CompositeSurface = cairo.ImageSurface.create_for_data \
		  (
			DisplayPixels, # data
			cairo.FORMAT_ARGB32, # format
			LoadedImage.ImageDrawSize[0], # width
			LoadedImage.ImageDrawSize[1], # height
			LoadedImage.RowStride # stride
		  )
		Composite = cairo.Context(CompositeSurface)
		Composite.set_source(CheckPattern)
		Composite.paint()
		if LoadedImage.Background != None :
			BackgroundPattern = cairo.SurfacePattern(LoadedImage.Background)
			BackgroundPattern.set_matrix \
			  (
				RectMatrix
				  (
					(0, 0) + LoadedImage.ImageDrawSize,
					(0, 0, LoadedImage.Background.get_width(), LoadedImage.Background.get_height())
				  )
			  )
			Composite.set_source(BackgroundPattern)
			Composite.paint()
		#end if
		Composite.set_source_surface \
		  (
			cairo.ImageSurface.create_for_data
			  (
				ImagePixels, # data
				cairo.FORMAT_ARGB32, # format
				LoadedImage.ImageDrawSize[0], # width
				LoadedImage.ImageDrawSize[1], # height
				LoadedImage.RowStride # stride
			  )
		  )
		Composite.paint()
		if HighlightPixels != None :
			Composite.set_source_surface \
			  (
				cairo.ImageSurface.create_for_data
				  (
					HighlightPixels, # data
					cairo.FORMAT_ARGB32, # format
					LoadedImage.ImageDrawSize[0], # width
					LoadedImage.ImageDrawSize[1], # height
					LoadedImage.RowStride # stride
				  )
			  )
			Composite.rectangle(*MainWindow.ButtonHighlightRect)
			Composite.fill()
		#end if
		CompositeSurface.flush()
		spuhelper.cairo_to_gtk(DisplayPixels)
		Offscreen = gtk.gdk.pixbuf_new_from_data \
		  (
			data = DisplayPixels.tostring(),
			colorspace = gtk.gdk.COLORSPACE_RGB,
			has_alpha = True,
			bits_per_sample = 8,
			width = LoadedImage.ImageDrawSize[0],
			height = LoadedImage.ImageDrawSize[1],
			rowstride = LoadedImage.RowStride
		  )
		MainWindow.ImageDisplay.set_from_pixbuf(Offscreen)
	#end if
#end DisplayImage

def LoadMenuImage(FileName) :
	"""loads a new SVG image file and also collects various useful information about it."""
	try :
		try :
			NewContents = XMLElementTree.parse(FileName)
		except xml.parsers.expat.ExpatError :
			raise Failure("Not a valid SVG file.")
		#end try
		NewLayers = {}
		NewLayerList = []
		SVGTag = NewContents.getroot()
		NewSrcDimensions = (float(SVGTag.get("width")), float(SVGTag.get("height")))
		AspectRatio = NewSrcDimensions[0] / NewSrcDimensions[1]
		AspectTolerance = 0.05 # give user some room to be sloppy
		if abs(AspectRatio / 4 * 3 - 1) <= AspectTolerance :
			Widescreen = False
		elif abs(AspectRatio / 16 * 9 - 1) <= AspectTolerance :
			Widescreen = True
		else :
			raise Failure("Image dimensions cannot be approximated as either 4:3 or 16:9")
		#end if
		for Layer in NewContents.findall("{%s}g" % ns.svg) :
			if Layer.get("{%s}groupmode" % ns.inkscape) == "layer" :
				LayerID = Layer.get("id")
				NewLayers[LayerID] = \
					{
						"visible" : Layer.get("style") != "display:none",
						  # save initial visibility state
						  # Assumption: Inkscape only sets style attribute to "display:inline"
						  # for visible layers and "display:none" for invisible ones
					}
				NewLayerList.append \
				  (
					(Layer.get("{%s}label" % ns.inkscape), LayerID)
				  )
			#end if
		#end for
		if len(NewLayerList) == 0 :
			raise Failure("No layers found in document. Are you sure it was created by Inkscape?")
		#end if
		if len(NewLayerList) == 1 :
			raise Failure("Need at least 2 layers, one for buttons and the rest for the image.")
		#end if
		# passed all validation checks
		MainWindow.Loading = True # suspend triggering of ColorDisplayChanged
		LoadedImage.FileName = FileName
		LoadedImage.Contents = NewContents
		LoadedImage.SrcDimensions = NewSrcDimensions
		LoadedImage.Widescreen = Widescreen
		MainWindow.LayerList.clear()
		for Layer in NewLayerList :
			MainWindow.LayerList.append(Layer)
		#end for
		LoadedImage.Layers = NewLayers
		MainWindow.LayerDisplay.get_selection().select_path((len(MainWindow.LayerList) - 1,))
		  # default to using top layer as buttons
		LoadedImage.ColorShowing = 0
		for Button in MainWindow.ColorButtonGroup.get_group() :
			Index = Button.get_data("index")
			Button.set_active(Index == 0)
			(Button.unset_flags, Button.set_flags)[Index == 0](gtk.SENSITIVE)
		#end for
		MainWindow.Loading = False
		ForgetButtonBlink()
		AnalyzeImage()
		DisplayImage()
	except Failure, Reason :
		ErrorAlert(Reason.Msg)
	#end try
#end LoadMenuImage

def LoadBackgroundImage(FileName) :
	"""loads a new background image."""
	try :
		try :
			ImagePixBuf = gtk.gdk.pixbuf_new_from_file(FileName)
		except glib.GError, Why :
			raise Failure(str(Why))
		#end try
		ImagePixArray = spuhelper.gtk_to_cairo_a(ImagePixBuf)
		LoadedImage.Background = cairo.ImageSurface.create_for_data \
		  (
			ImagePixArray, # data
			cairo.FORMAT_ARGB32, # format
			ImagePixBuf.get_property("width"), # width
			ImagePixBuf.get_property("height"), # height
			ImagePixBuf.get_property("width") * 4 # stride
		  )
		ForgetButtonBlink()
		DisplayImage()
	except Failure, Reason :
		ErrorAlert(Reason.Msg)
	#end try
#end LoadBackgroundImage

def FindButtons() :
	"""finds all button definitions in the selected button layer."""
	TheLayer = None # initial assumption
	SelectedLayerID = GetSingleListSelection(MainWindow.LayerDisplay, 1)
	if SelectedLayerID != None :
		for Layer in LoadedImage.Contents.findall("{%s}g" % ns.svg) :
			if Layer.get("id") == SelectedLayerID :
				TheLayer = Layer
				break
			#end if
		#end for
	#end if
	MainWindow.ButtonList.clear()
	if TheLayer != None :
		for Button in TheLayer.findall("{%s}rect" % ns.svg) :
			ButtonName = Button.get("id")
			ButtonBounds = \
				(
					float(Button.get("x")),
					float(Button.get("y")),
					float(Button.get("width")),
					float(Button.get("height")),
				)
			MainWindow.ButtonList.append((ButtonName, ButtonBounds))
		#end for
	#end if
#end FindButtons()

#+
# GUI callbacks
#-

def DestroyWindow(TheWindow) :
	# called when main window's close box is clicked.
	gtk.main_quit()
#end DestroyWindow

def SelectLoadMenuImage(TheWindow) :
	# lets the user choose an SVG file to load for the menu image.
	TheDialog = gtk.FileChooserDialog \
	  (
		title = "Choose SVG Image for Menu",
		action = gtk.FILE_CHOOSER_ACTION_OPEN,
		buttons = ("OK", gtk.RESPONSE_OK, "Cancel", gtk.RESPONSE_CANCEL)
	  )
	SVGFilter = gtk.FileFilter()
	SVGFilter.set_name("SVG Files")
	SVGFilter.add_pattern("*.svg")
	TheDialog.add_filter(SVGFilter)
	Response = TheDialog.run()
	if Response == gtk.RESPONSE_OK :
		ImageFileName = TheDialog.get_filename()
	else :
		ImageFileName = None
	#end if
	TheDialog.destroy()
	if ImageFileName != None :
		LoadMenuImage(ImageFileName)
	#end if
#end SelectLoadMenuImage

def SelectLoadBackgroundImage(TheWindow) :
	# lets the user choose a JPEG or PNG file to load for the background image.
	if LoadedImage.Contents == None :
		ErrorAlert("Load the menu image first.")
		  # because I'm not currently showing the background otherwise
	else :
		TheDialog = gtk.FileChooserDialog \
		  (
			title = "Choose JPEG or PNG Image for Background",
			action = gtk.FILE_CHOOSER_ACTION_OPEN,
			buttons = ("OK", gtk.RESPONSE_OK, "Cancel", gtk.RESPONSE_CANCEL)
		  )
		for Name, Pats in (("JPEG Files", ("*.jpg", "*.jpeg")), ("PNG Files", ("*.png",))) :
			TheFilter = gtk.FileFilter()
			TheFilter.set_name(Name)
			for Pat in Pats :
				TheFilter.add_pattern(Pat)
			#end for
			TheDialog.add_filter(TheFilter)
		#end for
		Response = TheDialog.run()
		if Response == gtk.RESPONSE_OK :
			ImageFileName = TheDialog.get_filename()
		else :
			ImageFileName = None
		#end if
		TheDialog.destroy()
		if ImageFileName != None :
			LoadBackgroundImage(ImageFileName)
		#end if
	#end if
#end SelectLoadBackgroundImage

def LayerSelectionChanged(TheSelection) :
	# called on a change to the selection of the button layer.
	ForgetButtonBlink()
	FindButtons()
	AnalyzeImage()
	DisplayImage()
#end LayerSelectionChanged

def ColorDisplayChanged(TheButton, Index) :
	if not MainWindow.Loading and TheButton.get_active() :
		LoadedImage.ColorShowing = Index
		ForgetButtonBlink()
		DisplayImage()
	#end if
#end ColorDisplayChanged

def EditColor(TreeView, ColorPath, ViewColumn) :
	# called when an item in a colour list is double-clicked.
	ForgetButtonBlink()
	if ColorPath[0] < 4 : # excess colours won't be saved anyway
		ColorList = TreeView.get_model()
		TheColor = ColorList.get_value(ColorList.get_iter(ColorPath), 0)
		ChooseNewColor = gtk.ColorSelectionDialog("Choose a colour, any colour")
		Chooser = ChooseNewColor.get_color_selection()
		Chooser.set_has_opacity_control(True)
		if TheColor[3] != 0 : # convert from premultiplied alpha
			Chooser.set_current_color \
			  (
				gtk.gdk.Color(*(i * 65535 // TheColor[3] for i in TheColor[:3]))
			  )
			Chooser.set_current_alpha(TheColor[3] * 257)
		else :
			Chooser.set_current_color(gtk.gdk.Color(0, 0, 0))
			Chooser.set_current_alpha(0)
		#end if
		Response = ChooseNewColor.run()
		if Response == ChooseNewColor.get_response_for_widget(ChooseNewColor.ok_button) :
			NewColor = Chooser.get_current_color()
			Opacity = Chooser.get_current_alpha() >> 8
			NewColor = \
				( # convert to premultiplied alpha
					NewColor.red // 257 * Opacity // 255,
					NewColor.green // 257 * Opacity // 255,
					NewColor.blue // 257 * Opacity // 255,
					Opacity,
				)
			ColorList.set_value(ColorList.get_iter(ColorPath), 0, NewColor)
			DisplayImage()
		#end if
		ChooseNewColor.destroy()
	#end if
#end EditColor

def DragGetColor(ColorList, DragContext, SelectionData, InfoID, TimeStamp) :
	# called on a drag to retrieve the colour spec from the drag source.
	TheColor = GetSingleListSelection(ColorList, 0)
	if TheColor != None :
		TheColor = ",".join(str(i) for i in TheColor[:4])
	else :
		TheColor = ""
	#end if
	SelectionData.set_text(TheColor, -1)
#end DragGetColor

def DragSetColor(ColorList, DragContext, DropX, DropY, SelectionData, InfoID, TimeStamp) :
	# called on a drag to save the colour spec into the drag destination.
	TheColor = SelectionData.get_text()
	ThePath = ColorList.get_path_at_pos(DropX, DropY)
	if ThePath != None and TheColor != "" :
		ThePath = ThePath[0]
		ThePath = (ThePath[0] - 1,) # FUDGE: GTK bug? returns one greater--is it including column header when computing cell y-offset?
		if ThePath[0] >= 0 and ThePath[0] < 4 :
			ColorList.get_model().set_value \
			  (
				ColorList.get_model().get_iter(ThePath),
				0,
				tuple(int(i) for i in TheColor.split(","))
			  )
			DisplayImage()
		#end if
	#end if
#end DragSetColor

def ButtonSelectionDone() :
	# timeout callback to turn off display of button in selected state
	MainWindow.ButtonBlinkTask = None
	MainWindow.ButtonSelected = False
	DisplayImage()
	return False # one-off invocation
#end ButtonSelectionDone

def ImageClickEvent(TheWidget, TheEvent) :
	Handled = False
	if LoadedImage.ColorShowing == 4 :
		if TheEvent.type == gtk.gdk.BUTTON_PRESS :
			MainWindow.ImageClick.grab_focus()
		elif TheEvent.type == gtk.gdk.BUTTON_RELEASE :
			pass
			# Handled = True
		elif TheEvent.type == gtk.gdk.FOCUS_CHANGE :
			if not TheEvent.in_ :
				ForgetButtonBlink()
				if MainWindow.ButtonHighlightRect != None :
					MainWindow.ButtonHighlightRect = None
					DisplayImage()
				#end if
			#end if
			# Handled = True
		elif TheEvent.type == gtk.gdk.KEY_PRESS :
			sys.stderr.write \
			  (
				"key press state = %d, val = %s\n" % (TheEvent.state, repr(TheEvent.keyval))
			  ) # debug
			if TheEvent.keyval in (keyval.returnkey, keyval.enterkey) :
				BlinkHighlightedButton()
			#end if
			# TBD up, down, left, right?
			Handled = True
		#end if
		if TheEvent.type == gtk.gdk.BUTTON_PRESS or TheEvent.type == gtk.gdk.MOTION_NOTIFY :
			FindButton = iter(MainWindow.ButtonList)
			while True :
				try :
					ThisButton = FindButton.next()
				except StopIteration :
					ThisButton = None
					break
				#end try
				ThisButton = ThisButton[1]
				ThisButton = \
					(
						ThisButton[0] * LoadedImage.ImageDrawSize[0] / LoadedImage.SrcDimensions[0],
						ThisButton[1] * LoadedImage.ImageDrawSize[1] / LoadedImage.SrcDimensions[1],
						ThisButton[2] * LoadedImage.ImageDrawSize[0] / LoadedImage.SrcDimensions[0],
						ThisButton[3] * LoadedImage.ImageDrawSize[1] / LoadedImage.SrcDimensions[1],
					)
				if (
						TheEvent.x >= ThisButton[0]
					and
						TheEvent.x < ThisButton[0] + ThisButton[2]
					and
						TheEvent.y >= ThisButton[1]
					and
						TheEvent.y < ThisButton[1] + ThisButton[3]
				) :
					break
				#end if
			#end while
			if ThisButton != MainWindow.ButtonHighlightRect :
				ForgetButtonBlink()
				MainWindow.ButtonHighlightRect = ThisButton
				DisplayImage()
			#end if
			# Handled = True
		#end if
		if TheEvent.type == gtk.gdk._2BUTTON_PRESS :
			if MainWindow.ButtonHighlightRect != None :
				BlinkHighlightedButton()
			#end if
			# Handled = True
		#end if
	#end if
	return Handled
#end ImageClickEvent

def AboutMe(TheWindow) :
	# displays a dialog showing information about the program.
	About = gtk.AboutDialog()
	About.set_name("DVD Menu Animator")
	About.set_version("0.01")
	About.set_comments("A utility to ease the construction of DVD-Video menus")
	About.set_copyright("© 2010 Lawrence D'Oliveiro")
	# About.set_license("GPLv3+")
	# About.set_authors(("Lawrence D'Oliveiro",))
	About.run()
	About.destroy()
#end AboutMe

#+
# Mainline
#-

def SetupMainWindow() :
	"""creates all the window widgets and attaches all associated event handlers."""
	global MainWindow
	MainWindow.Window = gtk.Window()
	MainWindow.Window.connect("destroy", DestroyWindow)
	CommonBoxMargin = 8
	MainPlusMenuBox = gtk.VBox(False, 0)
	MainMenuBar = BoxPack(gtk.MenuBar(), MainPlusMenuBox)
	MainBox = BoxPack(gtk.VBox(False, CommonBoxMargin), MainPlusMenuBox)
	MainBox.set_border_width(CommonBoxMargin)
	MenuAccelGroup = gtk.AccelGroup()
	MainWindow.Window.add_accel_group(MenuAccelGroup)
	FileMenu = NewMenu(MainMenuBar, "File")
	NewMenuItem(FileMenu, "Load Menu Image...", MenuAccelGroup, "O", SelectLoadMenuImage)
	NewMenuItem(FileMenu, "Load Background Image...", MenuAccelGroup, "B", SelectLoadBackgroundImage)
	NewMenuSeparatorItem(FileMenu)
	NewMenuItem(FileMenu, "Quit", MenuAccelGroup, "Q", gtk.main_quit)
	HelpMenu = NewMenu(MainMenuBar, "Help")
	NewMenuItem(HelpMenu, "About DVD Menu Animator...", None, None, AboutMe)
	MiddleBox = BoxPack(gtk.HBox(False, CommonBoxMargin), MainBox)
	MiddleBox.set_border_width(CommonBoxMargin)
	MainWindow.ImageClick = BoxPack(gtk.EventBox(), MiddleBox)
	MainWindow.ImageDisplay = gtk.Image()
	MainWindow.ImageClick.add(MainWindow.ImageDisplay)
	MainWindow.ImageClick.set_visible_window(False)
	MainWindow.ImageClick.set_above_child(True)
	MainWindow.ImageClick.set_flags(gtk.CAN_FOCUS)
	for \
		Signal \
	in \
		(
			"button-press-event",
			"button-release-event",
			"focus-in-event",
			"focus-out-event",
			"key-press-event",
			"motion-notify-event",
		) \
	:
		MainWindow.ImageClick.connect(Signal, ImageClickEvent)
	#end for
	ListsColBox = BoxPack(gtk.VBox(False, CommonBoxMargin), MiddleBox)
	List1Box = BoxPack(gtk.HBox(False, CommonBoxMargin), ListsColBox)
	RadioBox = BoxPack(gtk.VBox(False, CommonBoxMargin), List1Box)
	List2Box = BoxPack(gtk.HBox(False, CommonBoxMargin), ListsColBox)
	MainWindow.ColorButtonGroup = None
	MainWindow.Loading = True
	LoadedImage.ColorShowing = 0
	BoxPack(gtk.Label("Using Colours:"), RadioBox)
	for Index, Label in enumerate(("Original", "Normal", "Highlighted", "Selected", "Live")) :
		Button = BoxPack(gtk.RadioButton(MainWindow.ColorButtonGroup, Label), RadioBox)
		Button.set_data("index", Index)
		Button.set_active(MainWindow.ColorButtonGroup == None)
		if MainWindow.ColorButtonGroup == None :
			MainWindow.ColorButtonGroup = Button
		else :
			Button.unset_flags(gtk.SENSITIVE) # until an image is loaded
		#end if
		Button.connect("toggled", ColorDisplayChanged, Index)
	#end for
	MainWindow.LayerList = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_STRING)
	  # first col is display name, second is layer ID
	MainWindow.ButtonList = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_PYOBJECT)
	  # first col is button id/name, second is bounds tuple
	MainWindow.ButtonHighlightRect = None
	  # area to draw in highlighted/selected colours
	MainWindow.ButtonSelected = False
	MainWindow.ButtonBlinkTask = None
	MainWindow.ColorsNormalList = gtk.ListStore(gobject.TYPE_PYOBJECT)
	MainWindow.ColorsHighlightedList = gtk.ListStore(gobject.TYPE_PYOBJECT)
	MainWindow.ColorsSelectedList = gtk.ListStore(gobject.TYPE_PYOBJECT)
	NameListBounds = (160, 160)
	ColorListBounds = (120, 120)
	MainWindow.ButtonDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ButtonList,
		Col = 0,
		Renderer = None,
		ColAttribute = "text",
		Heading = "Buttons",
		Bounds = NameListBounds,
		OnSelectionChanged = None, # TBD perhaps sync list selection to live button selection
		AddToBox = List1Box
	  )
	MainWindow.LayerDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.LayerList,
		Col = 0,
		Renderer = None,
		ColAttribute = "text",
		Heading = "Button Layer",
		Bounds = NameListBounds,
		OnSelectionChanged = LayerSelectionChanged,
		AddToBox = List1Box
	  )
	MainWindow.ColorsNormalDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ColorsNormalList,
		Col = 0,
		Renderer = ColorCellRenderer(),
		ColAttribute = None,
		  # can't just simply add my own properties without registering them for an object class
		Heading = "Normal",
		Bounds = ColorListBounds,
		OnSelectionChanged = None,
		AddToBox = List2Box
	  )
	MainWindow.ColorsHighlightedDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ColorsHighlightedList,
		Col = 0,
		Renderer = ColorCellRenderer(),
		ColAttribute = None,
		Heading = "Highlight",
		Bounds = ColorListBounds,
		OnSelectionChanged = None,
		AddToBox = List2Box
	  )
	MainWindow.ColorsSelectedDisplay = DefineScrollingList \
	  (
		ListModel = MainWindow.ColorsSelectedList,
		Col = 0,
		Renderer = ColorCellRenderer(),
		ColAttribute = None,
		Heading = "Select",
		Bounds = ColorListBounds,
		OnSelectionChanged = None,
		AddToBox = List2Box
	  )
	for \
		ColorList \
	in \
		(
			MainWindow.ColorsNormalDisplay,
			MainWindow.ColorsHighlightedDisplay,
			MainWindow.ColorsSelectedDisplay,
		) \
	:
		ColorList.connect("row-activated", EditColor)
		ColorList.connect("drag-data-get", DragGetColor)
		ColorList.connect("drag-data-received", DragSetColor)
		ColorList.drag_dest_set \
		  (
			flags = gtk.DEST_DEFAULT_ALL,
			targets = ((gtk.gdk.TARGET_STRING, gtk.TARGET_SAME_APP, 1),),
			actions = gtk.gdk.ACTION_COPY
		  )
		ColorList.drag_source_set \
		  (
			start_button_mask = gtk.gdk.BUTTON1_MASK,
			targets = ((gtk.gdk.TARGET_STRING, gtk.TARGET_SAME_APP, 1),),
			actions = gtk.gdk.ACTION_COPY
		  )
	#end for
	MainWindow.StatusMsg = BoxPack(gtk.Label(), MainBox)
	MainWindow.Window.add(MainPlusMenuBox)
	MainWindow.Window.show_all()
#end SetupMainWindow

SetupMainWindow()
LoadedImage.Contents = None # to begin with
LoadedImage.Background = None # ditto
MainWindow.Window.show()
gtk.main()
